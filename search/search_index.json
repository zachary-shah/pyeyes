{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyeyes","text":"<p>pyeyes is an n-dimensional data visualization tool for comparing images, especially designed for MRI. It is built on Holoviews, Bokeh, and Panel for interactive plotting.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>User Guide \u2014 Viewer and GUI overview</li> <li>API Reference \u2014 Python API</li> <li>Changelog \u2014 Version history</li> <li>Contributing - For the interested devs</li> <li>Future Development - Open Issues and new feature requests</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install pyeyes\n</code></pre> <p>For a minimal example and more usage, see the README in the repository.</p>"},{"location":"api/","title":"API Overview","text":"<p>Main API \u2014 User-facing classes</p> <p>Core API \u2014 Lower-level components and utils</p>"},{"location":"api_core/","title":"Core Components","text":""},{"location":"api_core/#slicers","title":"Slicers","text":""},{"location":"api_core/#pyeyes.slicers.NDSlicer","title":"pyeyes.slicers.NDSlicer","text":"<pre><code>NDSlicer(data: Dataset, vdims: Sequence[str], cdim: Optional[str] = None, clabs: Optional[Sequence[str]] = None, cat_dims: Optional[Dict[str, List]] = None, cfg: Optional[Dict[str, str]] = None, plot_hooks: Optional[List[Callable]] = None, **params)\n</code></pre> <p>               Bases: <code>Parameterized</code></p> <p>Slicer for N-dimensional HoloViews Dataset; produces 2D view from slice indices.</p> PARAMETER DESCRIPTION <code>data</code> <p>Dataset with kdims (e.g. ImgName + spatial + slice dims) and Value vdim.</p> <p> TYPE: <code>Dataset</code> </p> <code>vdims</code> <p>Two dimension names used for the 2D view (e.g. ['x','y']).</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>cdim</code> <p>Collate dimension; if set, layout is 1D of 2D slices with labels.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>clabs</code> <p>Labels for cdim (required if cdim set).</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>cat_dims</code> <p>Categorical slice dimensions: dim name -&gt; list of options.</p> <p> TYPE: <code>Optional[Dict[str, List]]</code> DEFAULT: <code>None</code> </p> <code>cfg</code> <p>Slicer (and ROI) config from JSON.</p> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>plot_hooks</code> <p>Bokeh hooks (e.g. scroll) applied to plots.</p> <p> TYPE: <code>Optional[List[Callable]]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def __init__(\n    self,\n    data: hv.Dataset,\n    vdims: Sequence[str],\n    cdim: Optional[str] = None,\n    clabs: Optional[Sequence[str]] = None,\n    cat_dims: Optional[Dict[str, List]] = None,\n    cfg: Optional[Dict[str, str]] = None,\n    plot_hooks: Optional[List[Callable]] = None,\n    **params,\n):\n    \"\"\"\n    Slicer for N-dimensional HoloViews Dataset; produces 2D view from slice indices.\n\n    Parameters\n    ----------\n    data : hv.Dataset\n        Dataset with kdims (e.g. ImgName + spatial + slice dims) and Value vdim.\n    vdims : Sequence[str]\n        Two dimension names used for the 2D view (e.g. ['x','y']).\n    cdim : Optional[str]\n        Collate dimension; if set, layout is 1D of 2D slices with labels.\n    clabs : Optional[Sequence[str]]\n        Labels for cdim (required if cdim set).\n    cat_dims : Optional[Dict[str, List]]\n        Categorical slice dimensions: dim name -&gt; list of options.\n    cfg : Optional[Dict]\n        Slicer (and ROI) config from JSON.\n    plot_hooks : Optional[List[Callable]]\n        Bokeh hooks (e.g. scroll) applied to plots.\n    \"\"\"\n    # Not the most efficient, but now update from config if supplied. mimics user having manually\n    # set all parameters as desired.\n    # if supplied in config, vdims already taken care of by the viewer\n    from_config = cfg is not None\n\n    super().__init__(**params)\n\n    # additional hooks to add to the plot (for comms from slicer to viewer)\n    self.plot_hooks = plot_hooks\n    if self.plot_hooks is None:\n        self.plot_hooks = []\n\n    # initialize internal tracker of slice data\n    self._popout_active = False\n    self._curr_slice_data = None\n    self._pixel_warning_shown = False\n\n    with param.parameterized.discard_events(self):\n        self.data = data\n        self.cat_dims = cat_dims\n\n        # all dimensions\n        self.ndims = [d.name for d in data.kdims][::-1]\n\n        # Dictionary of all total size of each dimension\n        self.dim_sizes = {}\n        for dim in self.ndims:\n            self.dim_sizes[dim] = data.aggregate(dim, np.mean).data[dim].size\n\n        # Initialize slice cache\n        self.slice_cache = {}\n        for dim in self.ndims:\n            if dim in self.cat_dims.keys():\n                self.slice_cache[dim] = self.cat_dims[dim][self.dim_sizes[dim] // 2]\n            else:\n                self.slice_cache[dim] = self.dim_sizes[dim] // 2\n\n        assert len(vdims) == 2, \"Viewing dims must be length 2\"\n        assert np.array(\n            [vd in self.ndims for vd in vdims]\n        ).all(), \"Viewing dims must be in all dims\"\n\n        # collate-able dimension\n        if cdim is not None:\n            assert cdim in self.ndims, \"Collate dim must be in named dims\"\n\n            if clabs is not None:\n                assert (\n                    len(clabs) == self.dim_sizes[cdim]\n                ), \"Collate labels must match collate dimension size\"\n            else:\n                # assume data categorical.\n                clabs = (\n                    self.data.aggregate(self.cdim, np.mean).data[self.cdim].tolist()\n                )\n\n            self.clabs = clabs\n            self.cdim = cdim\n            self.Nc = self.dim_sizes[cdim]\n        else:\n            self.clabs = [\"Image\"]\n            self.cdim = None\n            self.Nc = 1\n\n        # Initialize cropping\n        self.crop_cache = {}\n        for dim in self.ndims:\n            self.crop_cache[dim] = (0, self.dim_sizes[dim])\n\n        # This sets self.vdims, self.sdims, self.non_sdims, and upates self.dim_indices param\n        self.set_volatile_dims(vdims, pre_cache=False)\n\n        # Initialize view cache\n        self.CPLX_VIEW_CLIM_CACHE = {}\n\n        # Set parameter attributes\n        if from_config:\n            config.deserialize_parameters(self, cfg[\"slicer_config\"])\n\n            # Excpeption for display images\n            if not cfg[\"metadata\"][\"same_images\"]:\n                self.display_images = self.clabs\n                self.param.display_images.objects = self.clabs\n                self.param.metrics_reference.objects = self.clabs\n                self.metrics_reference = self.clabs[0]\n\n            # Default display image titles\n            if not (\"display_image_titles\" in cfg[\"slicer_config\"]):\n                self.display_image_titles = {\n                    img_name: img_name for img_name in self.display_images\n                }\n\n            for k in self.clabs:\n                if k not in self.display_image_titles:\n                    warnings.warn(\n                        f'\"{k}\" not in config display titles. Using defaults.'\n                    )\n                    self.display_image_titles = {\n                        img_name: img_name for img_name in self.display_images\n                    }\n                    break\n\n            self.ROI = roi.ROI(config=cfg[\"roi_config\"])\n            self.update_cplx_view(\n                self.cplx_view, recompute_min_max=False, pre_cache=False\n            )\n            self.update_colormap()\n            self.update_roi_colormap(self.roi_cmap)\n\n            self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n\n        else:\n            # Initialize display images\n            self.param.display_images.objects = self.clabs\n            self.display_images = self.clabs\n            self.display_image_titles = {\n                img_name: img_name for img_name in self.display_images\n            }\n\n            # ROI init\n            self.ROI = roi.ROI()\n\n            # Update color limits with default\n            self.update_cplx_view(self.cplx_view, pre_cache=False)\n\n            # Color map object. Auto-select \"Quantitative\" if inferred from named dimensions.\n            if self._infer_quantitative_maptype() is not None:\n                self.ColorMapper = QuantitativeColorMap(\n                    self._infer_quantitative_maptype(), self.vmin, self.vmax\n                )\n                self.cmap = \"Quantitative\"\n            else:\n                self.ColorMapper = ColorMap(self.cmap)\n\n            # Diff map and metrics init\n            self.param.metrics_reference.objects = self.clabs\n            self.metrics_reference = self.clabs[0]  # Default to the first one\n            self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n\n    self.set_vmin_vmax()\n\n    # Initialize static instance of plot through self.Figure\n    self._build_figure_objects(self.slice())\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer-functions","title":"Functions","text":""},{"location":"api_core/#pyeyes.slicers.NDSlicer.slice","title":"slice","text":"<pre><code>slice(apply_colormap: bool = True, return_metrics: bool = True) -&gt; Dict\n</code></pre> <p>Return current 2D slice and optional error maps/metrics.</p> PARAMETER DESCRIPTION <code>apply_colormap</code> <p>If True, run ColorMapper.preprocess_data on image values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>return_metrics</code> <p>If True and metrics enabled, compute error maps and text metrics.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>\"img\": dict of hv.Dataset per display image; \"error_map\" and \"metrics\" if applicable.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def slice(self, apply_colormap: bool = True, return_metrics: bool = True) -&gt; Dict:\n    \"\"\"\n    Return current 2D slice and optional error maps/metrics.\n\n    Parameters\n    ----------\n    apply_colormap : bool\n        If True, run ColorMapper.preprocess_data on image values.\n    return_metrics : bool\n        If True and metrics enabled, compute error maps and text metrics.\n\n    Returns\n    -------\n    dict\n        \"img\": dict of hv.Dataset per display image; \"error_map\" and \"metrics\" if applicable.\n    \"\"\"\n    # Dimensions to select\n    sdim_dict = {dim: self.dim_indices[dim] for dim in self.sdims}\n\n    out_dict = {}\n\n    imgs = {}\n\n    # edge case where user has selected metrics but not the reference image for display\n    slice_imgs = self.display_images\n    if (\n        self.metrics_state is not METRICS_STATE.INACTIVE\n        and self.metrics_reference not in self.display_images\n    ):\n        slice_imgs = [self.metrics_reference] + self.display_images\n\n    if self.cdim is not None:\n        # Collate Case\n        for img_label in slice_imgs:\n\n            sliced_2d = self.data.select(\n                **{self.cdim: img_label}, **sdim_dict\n            ).reduce([self.cdim] + self.sdims, np.mean)\n\n            # order vdims in slice the same as self.vdims\n            sliced_2d = sliced_2d.reindex(self.vdims)\n\n            # set slice extent\n            l, r = self.lr_crop\n            u, d = self.ud_crop\n            sliced_2d = sliced_2d[l:r, u:d]\n\n            imgs[img_label] = sliced_2d\n    else:\n        # Single image case\n        sliced_2d = (\n            self.data.select(**sdim_dict)\n            .reduce(self.sdims, np.mean)\n            .reindex(self.vdims)\n        )\n\n        # set slice extent\n        l, r = self.lr_crop\n        u, d = self.ud_crop\n        sliced_2d = sliced_2d[l:r, u:d]\n\n        imgs[img_label] = sliced_2d\n\n    # Complex reduction\n    for k in imgs.keys():\n        imgs[k].data[\"Value\"] = CPLX_VIEW_MAP[self.cplx_view](imgs[k].data[\"Value\"])\n\n    \"\"\"\n    Gather metrics and difference maps of slice\n    \"\"\"\n    # TODO: integrate caching\n    if (self.metrics_state is not METRICS_STATE.INACTIVE) and return_metrics:\n        # Gather arrays\n        ref_img = np.copy(imgs[self.metrics_reference].data[\"Value\"])\n\n        tar_keys = [k for k in imgs.keys() if k != self.metrics_reference]\n\n        metrics_dict = {}\n        error_maps = {}\n\n        for k in tar_keys:\n\n            tar_img = np.copy(imgs[k].data[\"Value\"])\n\n            # NOTE: forced un-normalization for qmaps depreciated. option exposed to user.\n            if self.normalize_error_map or self.normalize_for_display:\n                tar_img = utils.normalize_scale(\n                    tar_img,\n                    ref_img,  # ofs=True, mag=np.iscomplexobj(tar_img)\n                )\n\n            if self.metrics_state in [METRICS_STATE.TEXT, METRICS_STATE.ALL]:\n                metrics_dict[k] = {}\n                for metric in self.metrics_text_types:\n                    metrics_dict[k][metric] = metrics.METRIC_CALLABLES[metric](\n                        tar_img,\n                        ref_img,\n                        isphase=self.cplx_view == \"phase\",\n                    )\n\n            if self.metrics_state in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n                error_map = metrics.METRIC_CALLABLES[self.error_map_type](\n                    tar_img,\n                    ref_img,\n                    return_map=True,\n                    isphase=self.cplx_view == \"phase\",\n                )\n                error_map = self.DifferenceColorMapper.preprocess_data(error_map)\n\n                # handle nan values returned bc of small pixel values\n                error_maps[k] = utils.clone_dataset(imgs[k], error_map, link=False)\n\n            # normalize displayed images\n            if self.normalize_for_display:\n                imgs[k].data[\"Value\"] = tar_img\n\n        # Ref\n        error_maps[self.metrics_reference] = utils.clone_dataset(\n            imgs[self.metrics_reference], np.zeros_like(ref_img), link=False\n        )\n\n        out_dict[\"metrics\"] = metrics_dict\n        out_dict[\"error_map\"] = error_maps\n\n    # don't want to display metrics reference\n    if (\n        self.metrics_state is not METRICS_STATE.INACTIVE\n        and self.metrics_reference not in self.display_images\n        and return_metrics\n    ):\n        imgs.pop(self.metrics_reference)\n\n    # Preprocessing for color map data\n    if apply_colormap:\n        for k in imgs.keys():\n            imgs[k].data[\"Value\"] = self.ColorMapper.preprocess_data(\n                imgs[k].data[\"Value\"]\n            )\n\n    out_dict[\"img\"] = imgs\n\n    # keep access to current slice data\n    self._curr_slice_data = out_dict\n\n    return out_dict\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.view","title":"view","text":"<pre><code>view() -&gt; hv.Layout\n</code></pre> <p>Return layout of current slice (rebuild or update figure as needed).</p> RETURNS DESCRIPTION <code>Layout</code> <p>Row/layout of images, optional ROI row, optional diff maps, colorbars.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>@param.depends(\"dim_indices\", \"rebuild_figure_flag\")\n@error.error_handler_decorator()\n@profilers.profile_decorator(\n    enable=False\n)  # Print call information or log to file for debugging\ndef view(self) -&gt; hv.Layout:\n    \"\"\"\n    Return layout of current slice (rebuild or update figure as needed).\n\n    Returns\n    -------\n    hv.Layout\n        Row/layout of images, optional ROI row, optional diff maps, colorbars.\n    \"\"\"\n    # Hold/unhold is necessary for making figure update \"atomized\". Not the best solution because\n    # there can be confusion between document state if multiple view calls are made before rendering\n    # is updated.\n    atomize = pn.state.curdoc and not self.rebuild_figure_flag\n\n    if atomize:\n        pn.state.curdoc.hold()\n\n    # New data to display\n    slice_dict = self.slice()\n\n    if self.rebuild_figure_flag:\n        with param.parameterized.discard_events(self):\n            self.rebuild_figure_flag = False\n\n        self._build_figure_objects(slice_dict)\n\n    else:\n        self._update_figure(slice_dict)\n\n    if atomize:\n        pn.state.curdoc.unhold()\n\n    return self.Figure\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.set_volatile_dims","title":"set_volatile_dims","text":"<pre><code>set_volatile_dims(vdims: Sequence[str], pre_cache: bool = True)\n</code></pre> <p>Set viewing dims and derive slicing dims, crop bounds, dim_indices.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def set_volatile_dims(self, vdims: Sequence[str], pre_cache: bool = True):\n    \"\"\"Set viewing dims and derive slicing dims, crop bounds, dim_indices.\"\"\"\n    if pre_cache:\n        self._update_cache()\n\n    with param.parameterized.discard_events(self):\n        self.clear_popup_pixel()\n\n        vdims = list(vdims)\n\n        self.vdims = vdims\n\n        if self.cdim is not None:\n            self.non_sdims = [self.cdim] + vdims\n        else:\n            self.non_sdims = vdims\n\n        # sliceable dimensions\n        self.sdims = [d for d in self.ndims if d not in self.non_sdims]\n\n        # Reset scroll dimension to first sdim when view dims change\n        self.scroll_dim = self.sdims[0] if self.sdims else None\n\n        # Update scaling for height and width ranges\n        self.img_dims = np.array([self.dim_sizes[vd] for vd in self.vdims])\n\n        # Update crop bounds\n        self.param.lr_crop.bounds = (0, int(self.img_dims[0]))\n        self.param.ud_crop.bounds = (0, int(self.img_dims[1]))\n        self.lr_crop = self.crop_cache[self.vdims[0]]\n        self.ud_crop = self.crop_cache[self.vdims[1]]\n\n        # Start in the center of each sliceable dimension\n        slice_dim_names = {}\n        for dim in self.sdims:\n            slice_dim_names[dim] = self.slice_cache[dim]\n\n        # Set default slice indicess\n        self.param.dim_indices.default = slice_dim_names\n        self.dim_indices = slice_dim_names\n\n    # trigger callbacks now\n    self.param.trigger(\"lr_crop\", \"ud_crop\", \"dim_indices\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.get_slice_data","title":"get_slice_data","text":"<pre><code>get_slice_data() -&gt; np.ndarray\n</code></pre> <p>Stack current slice image values (no colormap) into one array.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def get_slice_data(self) -&gt; np.ndarray:\n    \"\"\"Stack current slice image values (no colormap) into one array.\"\"\"\n    data = np.stack(\n        [\n            d.data[\"Value\"]\n            for d in self.slice(apply_colormap=False, return_metrics=False)[\n                \"img\"\n            ].values()\n        ]\n    )\n    data[np.isnan(data)] = 0\n    return data\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.get_data_lims","title":"get_data_lims","text":"<pre><code>get_data_lims() -&gt; Tuple[float, float]\n</code></pre> <p>Return (min, max) of current slice data.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def get_data_lims(self) -&gt; Tuple[float, float]:\n    \"\"\"Return (min, max) of current slice data.\"\"\"\n    data = self.get_slice_data()\n    return np.min(data), np.max(data)\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.set_vmin_vmax","title":"set_vmin_vmax","text":"<pre><code>set_vmin_vmax(vmin: Optional[float] = None, vmax: Optional[float] = None, dmin: Optional[float] = None, dmax: Optional[float] = None, bound_min: Optional[float] = None, bound_max: Optional[float] = None, step: Optional[float] = None)\n</code></pre> <p>Set vmin/vmax and slider bounds/step; return (vmin, vmax, bound_min, bound_max, step).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def set_vmin_vmax(\n    self,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    dmin: Optional[float] = None,\n    dmax: Optional[float] = None,\n    bound_min: Optional[float] = None,\n    bound_max: Optional[float] = None,\n    step: Optional[float] = None,\n):\n    \"\"\"Set vmin/vmax and slider bounds/step; return (vmin, vmax, bound_min, bound_max, step).\"\"\"\n    # current slice's data limits\n    if (dmin is None) or (dmax is None):\n        dmin, dmax = self.get_data_lims()\n\n    # desired contrast bounds\n    if vmin is None:\n        vmin = self.vmin\n    if vmax is None:\n        vmax = self.vmax\n\n    # Slider bounds\n    if bound_min is None:\n        if (\n            self.param.vmin.bounds is not None\n            and self.param.vmax.bounds is not None\n        ):\n            bound_min = min(self.param.vmin.bounds[0], self.param.vmax.bounds[0])\n        else:\n            bound_min = dmin\n    if bound_max is None:\n        if (\n            self.param.vmin.bounds is not None\n            and self.param.vmax.bounds is not None\n        ):\n            bound_max = max(self.param.vmin.bounds[1], self.param.vmax.bounds[1])\n        else:\n            bound_max = dmax\n\n    # Allow extending beyond data bounds if user desires (vmin/vmax)\n    bound_min = min(bound_min, vmin)\n    bound_max = max(bound_max, vmax)\n\n    # By default, keep clim bar within data bounds if desired vmin/vmax are within data bounds\n    if vmin &gt; dmin:\n        bound_min = dmin\n    if vmax &lt; dmax:\n        bound_max = dmax\n\n    # ensure data limits met\n    if vmin &gt; dmax:\n        pn.state.notifications.warning(\n            f\"Requested vmin={vmin:0.1e} &gt; data max={dmax:0.1e}. Setting vmin to data max.\"\n        )\n        vmin = dmax\n    if vmax &lt; dmin:\n        pn.state.notifications.warning(\n            f\"Requested vmax={vmax:0.1e} &lt; data min={dmin:0.1e}. Setting vmax to data min.\"\n        )\n        vmax = dmin\n\n    # Equal vmin / vmax case\n    if vmin == vmax:\n        if vmin == 0:\n            msg = \"Requested min = max = 0. Setting vmin/vmax to -1/1.\"\n        else:\n            msg = f\"Data min = max = {dmin:0.1e}. Setting vmin/vmax to {dmin:0.1e} +/- 1.\"\n        pn.state.notifications.warning(msg)\n        vmin = vmin - 1\n        vmax = vmax + 1\n        bound_min = min(bound_min, vmin - 1)\n        bound_max = max(bound_max, vmax + 1)\n        step = step or 0.1\n    else:\n        if dmin == dmax:\n            step = (bound_max - bound_min) / 100\n        else:\n            step = step or (dmax - dmin) / 100\n\n    step = max(step, TOL)\n\n    self.param.vmin.bounds = (bound_min, bound_max)\n    self.param.vmax.bounds = (bound_min, bound_max)\n    self.param.vmin.step = step\n    self.param.vmax.step = step\n    self.vmin = vmin\n    self.vmax = vmax\n    self.param.vmin.default = vmin\n    self.param.vmax.default = vmax\n\n    self._update_cache()\n\n    return vmin, vmax, bound_min, bound_max, step\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.get_autoscale_lims","title":"get_autoscale_lims","text":"<pre><code>get_autoscale_lims() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Return (dmin, dmax, vmin, vmax) using data percentiles (phase: -pi, pi).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def get_autoscale_lims(self) -&gt; Tuple[float, float, float, float]:\n    \"\"\"Return (dmin, dmax, vmin, vmax) using data percentiles (phase: -pi, pi).\"\"\"\n    data = self.get_slice_data()\n\n    if self.cplx_view == \"phase\":\n        dmin, dmax = -np.pi, np.pi\n    else:\n        dmin = np.min(data)\n        dmax = np.max(data)\n\n    vmin = np.percentile(data, 0.1)\n    vmax = np.percentile(data, 99.9)\n\n    return dmin, dmax, vmin, vmax\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.autoscale_clim","title":"autoscale_clim","text":"<pre><code>autoscale_clim()\n</code></pre> <p>Set vmin/vmax from percentiles and return (vmin, vmax, bound_min, bound_max, step).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def autoscale_clim(self):\n    \"\"\"Set vmin/vmax from percentiles and return (vmin, vmax, bound_min, bound_max, step).\"\"\"\n    with param.parameterized.discard_events(self):\n        # Get data limits and auto-scale by percentiles\n        dmin, dmax, vmin, vmax = self.get_autoscale_lims()\n\n        # supply this to set_vmin_vmax to avoid recomputing data limits\n        vmin, vmax, bound_min, bound_max, step = self.set_vmin_vmax(\n            vmin=vmin,\n            vmax=vmax,\n            dmin=dmin,\n            dmax=dmax,\n            bound_min=dmin,\n            bound_max=dmax,\n        )\n\n    self.param.trigger(\"vmin\", \"vmax\")\n\n    return vmin, vmax, bound_min, bound_max, step\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_display_image_list","title":"update_display_image_list","text":"<pre><code>update_display_image_list(display_images: Sequence[str])\n</code></pre> <p>Set which images are displayed.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_display_image_list(self, display_images: Sequence[str]):\n    \"\"\"Set which images are displayed.\"\"\"\n    self.display_images = display_images\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_colormap","title":"update_colormap","text":"<pre><code>update_colormap()\n</code></pre> <p>Refresh ColorMapper from cmap param (including Quantitative).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_colormap(self):\n    \"\"\"Refresh ColorMapper from cmap param (including Quantitative).\"\"\"\n    if self.cmap.capitalize() == \"Quantitative\":\n        qmaptype = self._infer_quantitative_maptype()\n\n        if qmaptype is not None:\n            self.ColorMapper = QuantitativeColorMap(qmaptype, self.vmin, self.vmax)\n\n        else:\n            # TODO: parameterize what colormap should be default\n            error.warning(\n                \"Could not infer quantitative maptype. Using default colormap 'gray'.\"\n            )\n            self.ColorMapper = ColorMap(\"gray\")\n    else:\n        self.ColorMapper = ColorMap(self.cmap)\n\n    # Ensure roi tracks with colormap updates if paired\n    if self.roi_cmap.capitalize() == \"Same\":\n        with param.parameterized.discard_events(self):\n            self.update_roi_colormap(self.roi_cmap)\n\n    self.param.trigger(\"cmap\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_colormap","title":"update_roi_colormap","text":"<pre><code>update_roi_colormap(new_cmap: str)\n</code></pre> <p>Set ROI colormap (Same / Quantitative / named).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_colormap(self, new_cmap: str):\n    \"\"\"Set ROI colormap (Same / Quantitative / named).\"\"\"\n    self.roi_cmap = new_cmap\n\n    if self.roi_cmap.capitalize() == \"Same\":\n        self.ROI.cmap = self.ColorMapper\n\n    elif self.roi_cmap.capitalize() == \"Quantitative\":\n        qmaptype = self._infer_quantitative_maptype()\n\n        if qmaptype is not None:\n            self.ROI.cmap = QuantitativeColorMap(qmaptype, self.vmin, self.vmax)\n\n        else:\n            self.ROI.cmap = self.ColorMapper\n\n    else:\n        self.ROI.cmap = ColorMap(self.roi_cmap)\n\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_zoom_scale","title":"update_roi_zoom_scale","text":"<pre><code>update_roi_zoom_scale(new_zoom: float)\n</code></pre> <p>Set ROI zoom scale and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_zoom_scale(self, new_zoom: float):\n    \"\"\"Set ROI zoom scale and trigger redraw.\"\"\"\n    self.ROI.zoom_scale = new_zoom\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_loc","title":"update_roi_loc","text":"<pre><code>update_roi_loc(new_loc: str)\n</code></pre> <p>Set ROI overlay corner and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_loc(self, new_loc: str):\n    \"\"\"Set ROI overlay corner and trigger redraw.\"\"\"\n    self.ROI.roi_loc = ROI_LOCATION(new_loc)\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_lr_crop","title":"update_roi_lr_crop","text":"<pre><code>update_roi_lr_crop(new_lr_crop: Tuple[int, int])\n</code></pre> <p>Set ROI left/right crop and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_lr_crop(self, new_lr_crop: Tuple[int, int]):\n    \"\"\"Set ROI left/right crop and trigger redraw.\"\"\"\n    self.ROI.set_xrange(*new_lr_crop)\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_ud_crop","title":"update_roi_ud_crop","text":"<pre><code>update_roi_ud_crop(new_ud_crop: Tuple[int, int])\n</code></pre> <p>Set ROI up/down crop and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_ud_crop(self, new_ud_crop: Tuple[int, int]):\n    \"\"\"Set ROI up/down crop and trigger redraw.\"\"\"\n    self.ROI.set_yrange(*new_ud_crop)\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_line_color","title":"update_roi_line_color","text":"<pre><code>update_roi_line_color(new_color: str)\n</code></pre> <p>Set ROI border color and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_line_color(self, new_color: str):\n    \"\"\"Set ROI border color and trigger redraw.\"\"\"\n    self.ROI.color = new_color\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_line_width","title":"update_roi_line_width","text":"<pre><code>update_roi_line_width(new_width: int)\n</code></pre> <p>Set ROI border width and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_line_width(self, new_width: int):\n    \"\"\"Set ROI border width and trigger redraw.\"\"\"\n    self.ROI.line_width = new_width\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_zoom_order","title":"update_roi_zoom_order","text":"<pre><code>update_roi_zoom_order(new_order: int)\n</code></pre> <p>Set ROI zoom interpolation order and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_zoom_order(self, new_order: int):\n    \"\"\"Set ROI zoom interpolation order and trigger redraw.\"\"\"\n    self.ROI.zoom_order = new_order\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_mode","title":"update_roi_mode","text":"<pre><code>update_roi_mode(new_mode: int)\n</code></pre> <p>Set ROI view mode (overlay vs separate) and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_mode(self, new_mode: int):\n    \"\"\"Set ROI view mode (overlay vs separate) and trigger redraw.\"\"\"\n    self.roi_mode = ROI_VIEW_MODE(new_mode)\n    self.param.trigger(\"roi_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_roi_state","title":"update_roi_state","text":"<pre><code>update_roi_state(new_state: ROI_STATE)\n</code></pre> <p>Set ROI state (inactive / first_click / second_click / active) and show message.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_roi_state(self, new_state: ROI_STATE):\n    \"\"\"Set ROI state (inactive / first_click / second_click / active) and show message.\"\"\"\n    prev_state = self.roi_state\n\n    # State-based update and display corresponding message\n    if prev_state == ROI_STATE.INACTIVE and new_state == ROI_STATE.INACTIVE:\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"No ROI active. Click 'Draw ROI' to start adding an ROI.\",\n            duration=0,\n        )\n\n    elif prev_state &gt; ROI_STATE.INACTIVE and new_state == ROI_STATE.INACTIVE:\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"ROI cleared. Click 'Draw ROI' to start adding an ROI.\",\n            duration=3000,\n        )\n\n    elif prev_state &gt; ROI_STATE.INACTIVE and new_state == ROI_STATE.FIRST_SELECTION:\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"Resetting ROI. Click the first corner of the new ROI in any top-row image.\",\n            duration=0,\n        )\n\n    elif (\n        prev_state == ROI_STATE.INACTIVE and new_state == ROI_STATE.FIRST_SELECTION\n    ):\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"Click the first corner of the ROI in any top-row image.\",\n            duration=0,\n        )\n\n    elif (\n        prev_state == ROI_STATE.FIRST_SELECTION\n        and new_state == ROI_STATE.SECOND_SELECTION\n    ):\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"Click the second corner of the ROI in any image.\",\n            duration=0,\n        )\n\n    elif prev_state == ROI_STATE.SECOND_SELECTION and new_state == ROI_STATE.ACTIVE:\n        pn.state.notifications.clear()\n        pn.state.notifications.info(\n            \"ROI added. Remove ROI with 'Clear ROI' button, or remove from overlay by un-checcking 'ROI Overlay Enabled'.\",  # noqa E501\n            duration=5000,\n        )\n\n        with param.parameterized.discard_events(self):\n            self.update_roi_colormap(self.roi_cmap)\n\n    else:\n\n        raise ValueError(\n            f\"Invalid ROI state transition: {prev_state} -&gt; {new_state}\"\n        )\n\n    # Trigger\n    self.roi_state = new_state\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_reference_dataset","title":"update_reference_dataset","text":"<pre><code>update_reference_dataset(new_ref: str)\n</code></pre> <p>Set reference image for metrics and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_reference_dataset(self, new_ref: str):\n    \"\"\"Set reference image for metrics and trigger redraw.\"\"\"\n    self.metrics_reference = new_ref\n    if self.metrics_state != METRICS_STATE.INACTIVE:\n        self.param.trigger(\"metrics_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_error_map_type","title":"update_error_map_type","text":"<pre><code>update_error_map_type(new_type: str)\n</code></pre> <p>Set error map metric type and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_error_map_type(self, new_type: str):\n    \"\"\"Set error map metric type and trigger redraw.\"\"\"\n    self.error_map_type = new_type\n    if self.metrics_state in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n        self.param.trigger(\"metrics_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_metrics_text_types","title":"update_metrics_text_types","text":"<pre><code>update_metrics_text_types(new_metrics: List[str])\n</code></pre> <p>Set which metrics to show as text and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_metrics_text_types(self, new_metrics: List[str]):\n    \"\"\"Set which metrics to show as text and trigger redraw.\"\"\"\n    self.metrics_text_types = new_metrics\n    if self.metrics_state in [METRICS_STATE.TEXT, METRICS_STATE.ALL]:\n        self.param.trigger(\"metrics_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_metrics_state","title":"update_metrics_state","text":"<pre><code>update_metrics_state(new_metrics_state: METRICS_STATE)\n</code></pre> <p>Set metrics state (inactive / map / text / all).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_metrics_state(self, new_metrics_state: METRICS_STATE):\n    \"\"\"Set metrics state (inactive / map / text / all).\"\"\"\n    self.metrics_state = new_metrics_state\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_error_map_scale","title":"update_error_map_scale","text":"<pre><code>update_error_map_scale(new_scale: float)\n</code></pre> <p>Set error map scale and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_error_map_scale(self, new_scale: float):\n    \"\"\"Set error map scale and trigger redraw.\"\"\"\n    with param.parameterized.discard_events(self):\n        self.error_map_scale = new_scale\n    if self.metrics_state in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n        self.param.trigger(\"error_map_scale\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_error_map_cmap","title":"update_error_map_cmap","text":"<pre><code>update_error_map_cmap(new_cmap: str)\n</code></pre> <p>Set error map colormap and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_error_map_cmap(self, new_cmap: str):\n    \"\"\"Set error map colormap and trigger redraw.\"\"\"\n    self.error_map_cmap = new_cmap\n    self.DifferenceColorMapper = ColorMap(new_cmap)\n    if self.metrics_state in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n        self.param.trigger(\"error_map_scale\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_normalize_error_map","title":"update_normalize_error_map","text":"<pre><code>update_normalize_error_map(normalize: bool)\n</code></pre> <p>Toggle error-map normalization and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_normalize_error_map(self, normalize: bool):\n    \"\"\"Toggle error-map normalization and trigger redraw.\"\"\"\n    self.normalize_error_map = normalize\n    if self.metrics_state in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n        self.param.trigger(\"error_map_scale\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_metrics_text_font_size","title":"update_metrics_text_font_size","text":"<pre><code>update_metrics_text_font_size(new_size: int)\n</code></pre> <p>Set metrics text font size and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_metrics_text_font_size(self, new_size: int):\n    \"\"\"Set metrics text font size and trigger redraw.\"\"\"\n    self.metrics_text_font_size = new_size\n    if self.metrics_state in [METRICS_STATE.TEXT, METRICS_STATE.ALL]:\n        self.param.trigger(\"metrics_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_metrics_text_location","title":"update_metrics_text_location","text":"<pre><code>update_metrics_text_location(new_loc: ROI_LOCATION)\n</code></pre> <p>Set corner for metrics text overlay and trigger redraw.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_metrics_text_location(self, new_loc: ROI_LOCATION):\n    \"\"\"Set corner for metrics text overlay and trigger redraw.\"\"\"\n    self.metrics_text_location = new_loc\n    if self.metrics_state in [METRICS_STATE.TEXT, METRICS_STATE.ALL]:\n        self.param.trigger(\"metrics_state\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.clear_popup_pixel","title":"clear_popup_pixel","text":"<pre><code>clear_popup_pixel()\n</code></pre> <p>Clear popup pixel overlay and coordinates.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def clear_popup_pixel(self):\n    \"\"\"Clear popup pixel overlay and coordinates.\"\"\"\n    if (\n        not self._popout_active\n        and self.popup_pixel_coordinate_x &lt; 0\n        and self.popup_pixel_coordinate_y &lt; 0\n    ):\n        return\n\n    self._popout_active = False\n    self.popup_pixel_coordinate_x = -1\n    self.popup_pixel_coordinate_y = -1\n    self.param.trigger(\"popup_pixel_enabled\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.update_popup_pixel_enabled","title":"update_popup_pixel_enabled","text":"<pre><code>update_popup_pixel_enabled(new_val: bool)\n</code></pre> <p>Enable/disable popup pixel inspection and clear if disabling.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def update_popup_pixel_enabled(self, new_val: bool):\n    \"\"\"Enable/disable popup pixel inspection and clear if disabling.\"\"\"\n    old_val = self.popup_pixel_enabled\n    if old_val == new_val:\n        return  # no change\n\n    self.popup_pixel_enabled = new_val\n    if not new_val:\n        with param.parameterized.discard_events(self):\n            self.clear_popup_pixel()\n\n    self.param.trigger(\"popup_pixel_enabled\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.autoformat_error_map","title":"autoformat_error_map","text":"<pre><code>autoformat_error_map()\n</code></pre> <p>Set error map scale and cmap from data (e.g. match main image scale).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def autoformat_error_map(self):\n    \"\"\"Set error map scale and cmap from data (e.g. match main image scale).\"\"\"\n    if self.metrics_state not in [METRICS_STATE.MAP, METRICS_STATE.ALL]:\n        error.warning(\"Error maps are not enabled.\")\n        return\n\n    if self.error_map_type == \"SSIM\":\n        self.error_map_cmap = \"Grays\"\n        self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n\n    elif self.error_map_type in [\"L1Diff\", \"L2Diff\"]:\n\n        if self.DifferenceColorMapper.cmap == \"Grays\":\n            self.error_map_cmap = \"inferno\"\n            self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n\n        error_max = self.get_max_err()\n\n        if error_max &gt; ERROR_TOL:\n            self.error_map_scale = round(self.vmax / error_max, 1)\n\n    elif self.error_map_type == \"Diff\":\n        self.error_map_cmap = \"RdBu\"\n        self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n        error_max = np.abs(self.get_max_err())\n\n        if error_max &gt; ERROR_TOL:\n            error_max = np.abs(self.get_max_err())\n            self.error_map_scale = round(self.vmax / error_max, 1)\n\n    elif self.error_map_type == \"RelativeL1\":\n        self.error_map_cmap = \"inferno\"\n        self.DifferenceColorMapper = ColorMap(self.error_map_cmap)\n        self.error_map_scale = round(self.vmax)\n\n    else:\n        error.warning(\"Error map type does not have autoformat.\")\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.get_max_err","title":"get_max_err","text":"<pre><code>get_max_err()\n</code></pre> <p>Return 99.9th percentile of current slice error map values.</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def get_max_err(self):\n    \"\"\"Return 99.9th percentile of current slice error map values.\"\"\"\n    error_data = self.slice()[\"error_map\"]\n\n    if self.metrics_reference in error_data:\n        error_data.pop(self.metrics_reference)\n\n    error_np = np.stack([d.data[\"Value\"] for d in error_data.values()])\n    error_np[np.isnan(error_np)] = 0\n\n    return np.percentile(error_np, 99.9)\n</code></pre>"},{"location":"api_core/#pyeyes.slicers.NDSlicer.compute_scroll_delta","title":"compute_scroll_delta","text":"<pre><code>compute_scroll_delta(delta: float) -&gt; Tuple[Optional[str], Optional[Union[int, str]]]\n</code></pre> <p>Increment/decrement scroll_dim by delta; return (dim_name, new_value) or (None, None).</p> Source code in <code>src/pyeyes/slicers.py</code> <pre><code>def compute_scroll_delta(\n    self, delta: float\n) -&gt; Tuple[Optional[str], Optional[Union[int, str]]]:\n    \"\"\"Increment/decrement scroll_dim by delta; return (dim_name, new_value) or (None, None).\"\"\"\n    if self.scroll_dim is None or self.scroll_dim not in self.sdims:\n        return None, None\n\n    # Determine scroll direction (positive delta = scroll up = increment)\n    move_amt = 1 if (abs(delta) &gt; 1e-2) else 0\n    direction = 1 if delta &gt; 0 else -1\n    move_amt = move_amt * direction\n    move_amt = int(round(move_amt))\n\n    # Handle categorical vs numeric dimensions\n    if self.scroll_dim in self.cat_dims:\n        # Cycle through categorical options\n        options = self.cat_dims[self.scroll_dim]\n        current_value = self.dim_indices[self.scroll_dim]\n        try:\n            current_idx = options.index(current_value)\n        except ValueError:\n            current_idx = 0\n        new_idx = (current_idx + direction) % len(options)\n        new_value = options[new_idx]\n        new_value = str(new_value)\n    else:\n        # Numeric dimension - increment/decrement with bounds checking\n        current = self.dim_indices[self.scroll_dim]\n        max_val = self.dim_sizes[self.scroll_dim] - 1\n        new_value = max(0, min(max_val, current + move_amt))\n        new_value = int(new_value)\n\n    return str(self.scroll_dim), new_value\n</code></pre>"},{"location":"api_core/#metrics","title":"Metrics","text":""},{"location":"api_core/#pyeyes.metrics","title":"pyeyes.metrics","text":""},{"location":"api_core/#pyeyes.metrics-functions","title":"Functions","text":""},{"location":"api_core/#pyeyes.metrics.diff","title":"diff","text":"<pre><code>diff(recon: ndarray, true: ndarray, return_map=False, isphase=False) -&gt; float\n</code></pre> <p>Mean difference (or diff map) between recon and true; phase-aware if isphase.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def diff(recon: np.ndarray, true: np.ndarray, return_map=False, isphase=False) -&gt; float:\n    \"\"\"Mean difference (or diff map) between recon and true; phase-aware if isphase.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    if isphase:\n        diff_map = np.angle(np.exp(1j * recon) / np.exp(1j * true))\n    else:\n        diff_map = recon - true\n\n    if return_map:\n        return diff_map\n\n    return np.mean(diff_map)\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.L1Diff","title":"L1Diff","text":"<pre><code>L1Diff(recon: ndarray, true: ndarray, return_map=False, isphase=False) -&gt; float\n</code></pre> <p>L1 difference (mean or map); phase-aware if isphase.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def L1Diff(\n    recon: np.ndarray, true: np.ndarray, return_map=False, isphase=False\n) -&gt; float:\n    \"\"\"L1 difference (mean or map); phase-aware if isphase.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    diff_map = diff(recon, true, return_map=True, isphase=isphase)\n\n    l1_diff = np.abs(diff_map)\n\n    if return_map:\n        # prevent returning all nans\n        if np.max(l1_diff) &lt; TOL:\n            return np.zeros_like(l1_diff)\n\n        im_mask = (np.abs(true) - np.min(np.abs(true))) &lt; SCALE_TOL * np.max(\n            np.abs(true)\n        )\n\n        l1_diff[(l1_diff &lt; TOL) &amp; im_mask] = np.nan\n        return l1_diff\n\n    return np.mean(l1_diff)\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.RelativeL1","title":"RelativeL1","text":"<pre><code>RelativeL1(recon: ndarray, true: ndarray, return_map=False, isphase=False) -&gt; float\n</code></pre> <p>Relative L1 (|recon-true|/|true|); mean or map; phase-aware if isphase.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def RelativeL1(\n    recon: np.ndarray,\n    true: np.ndarray,\n    return_map=False,\n    isphase=False,\n) -&gt; float:\n    \"\"\"Relative L1 (|recon-true|/|true|); mean or map; phase-aware if isphase.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    diff_map = diff(recon, true, return_map=True, isphase=isphase)\n    mx = np.max(np.abs(true))\n    rel_diff = np.abs(diff_map) / (np.abs(true) + TOL * mx)\n    valid = np.abs(true) &gt; TOL * mx\n\n    if return_map:\n        if np.sum(valid) == 0:\n            return np.zeros_like(rel_diff)\n\n        rel_diff[~valid] = np.nan\n\n        return rel_diff\n\n    if np.sum(valid) == 0:\n        return 0.0\n\n    return np.mean(rel_diff[valid])\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.RMSE","title":"RMSE","text":"<pre><code>RMSE(recon: ndarray, true: ndarray, return_map=False, isphase=False) -&gt; float\n</code></pre> <p>RMSE = sqrt(mean(|recon-true|^2)); return scalar or map; phase-aware if isphase.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def RMSE(recon: np.ndarray, true: np.ndarray, return_map=False, isphase=False) -&gt; float:\n    \"\"\"RMSE = sqrt(mean(|recon-true|^2)); return scalar or map; phase-aware if isphase.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    diff_map = diff(recon, true, return_map=True, isphase=isphase)\n\n    mse = np.abs(diff_map) ** 2\n\n    if return_map:\n        mse = np.sqrt(mse)\n\n        # prevent returning all nans\n        if np.max(mse) &lt; TOL:\n            return np.zeros_like(mse)\n\n        mse[mse &lt; TOL] = np.nan\n        return mse\n\n    return np.sqrt(np.mean(mse))\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.NRMSE","title":"NRMSE","text":"<pre><code>NRMSE(recon: ndarray, true: ndarray, return_map=False, isphase=False) -&gt; float\n</code></pre> <p>NRMSE = sqrt(mean(|recon-true|^2) / mean(|true|^2)); scalar or map; phase-aware if isphase.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def NRMSE(\n    recon: np.ndarray, true: np.ndarray, return_map=False, isphase=False\n) -&gt; float:\n    \"\"\"NRMSE = sqrt(mean(|recon-true|^2) / mean(|true|^2)); scalar or map; phase-aware if isphase.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    diff_map = diff(recon, true, return_map=True, isphase=isphase)\n\n    mse = np.abs(diff_map) ** 2\n\n    if return_map:\n        if np.max(np.abs(true)) &lt; TOL:\n            return np.zeros_like(mse)\n        nrmse = mse / ((np.abs(true) ** 2) + (TOL**2))\n        nrmse = np.sqrt(nrmse)\n        nrmse[nrmse &lt; TOL] = np.nan\n        nrmse[nrmse &gt; (1 / TOL)] = np.nan\n        if np.nanmax(nrmse) &lt; TOL:\n            return np.zeros_like(nrmse)\n        return nrmse\n\n    nrmse = np.mean(mse) / (np.mean(np.abs(true) ** 2) + (TOL**2))\n    return np.sqrt(nrmse)\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.SSIM","title":"SSIM","text":"<pre><code>SSIM(recon: ndarray, true: ndarray, return_map=False, isphase=False, percentiles=[0.5, 99.5]) -&gt; float\n</code></pre> <p>Structural similarity index (skimage); data_range from percentiles of |true|.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def SSIM(\n    recon: np.ndarray,\n    true: np.ndarray,\n    return_map=False,\n    isphase=False,\n    percentiles=[0.5, 99.5],\n) -&gt; float:\n    \"\"\"Structural similarity index (skimage); data_range from percentiles of |true|.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    if isphase:\n        pass  # do nothing different, but SSIM doesn't really make sense for phase maps\n\n    true_abs = np.abs(true)\n    upper_bound = np.percentile(true_abs, percentiles[1])\n    lower_bound = np.percentile(true_abs, percentiles[0])\n    data_range = upper_bound - lower_bound\n\n    # all zeros case\n    if data_range &lt; TOL:\n        if return_map:\n            return np.ones_like(recon)\n        else:\n            return 1.0\n\n    if return_map:\n        ssim_map = compare_ssim(recon, true, full=True, data_range=data_range)[1]\n        return ssim_map\n\n    return compare_ssim(recon, true, data_range=data_range)\n</code></pre>"},{"location":"api_core/#pyeyes.metrics.PSNR","title":"PSNR","text":"<pre><code>PSNR(recon: ndarray, true: ndarray, isphase=False, max_percentile=99.5) -&gt; float\n</code></pre> <p>PSNR in dB using max_percentile of |true| as peak; RMSE for error.</p> Source code in <code>src/pyeyes/metrics.py</code> <pre><code>def PSNR(\n    recon: np.ndarray, true: np.ndarray, isphase=False, max_percentile=99.5\n) -&gt; float:\n    \"\"\"PSNR in dB using max_percentile of |true| as peak; RMSE for error.\"\"\"\n    assert recon.shape == true.shape, \"Input array dimensions mismatch.\"\n\n    max_val = np.percentile(np.abs(true), max_percentile)\n\n    if max_val &lt; TOL:\n        return np.inf\n\n    rmse = RMSE(recon, true, isphase=isphase)\n\n    if rmse &lt; TOL:\n        return np.inf\n\n    psnr = 20 * np.log10(max_val / rmse)\n\n    return psnr\n</code></pre>"},{"location":"api_core/#colormaps","title":"Colormaps","text":""},{"location":"api_core/#pyeyes.cmap.cmap.ColorMap","title":"pyeyes.cmap.cmap.ColorMap","text":"<pre><code>ColorMap(cmap: Union[ListedColormap, str])\n</code></pre> <p>Base colormap: pass-through preprocess_data and get_cmap by name or ListedColormap.</p> <p>Store colormap (name or ListedColormap).</p> PARAMETER DESCRIPTION <code>cmap</code> <p>Colormap name (e.g. 'gray') or instance.</p> <p> TYPE: <code>str or ListedColormap</code> </p> Source code in <code>src/pyeyes/cmap/cmap.py</code> <pre><code>def __init__(self, cmap: Union[mcolors.ListedColormap, str]):\n    \"\"\"\n    Store colormap (name or ListedColormap).\n\n    Parameters\n    ----------\n    cmap : str or matplotlib.colors.ListedColormap\n        Colormap name (e.g. 'gray') or instance.\n    \"\"\"\n    self.cmap = cmap\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.cmap.ColorMap-functions","title":"Functions","text":""},{"location":"api_core/#pyeyes.cmap.cmap.ColorMap.preprocess_data","title":"preprocess_data","text":"<pre><code>preprocess_data(x: ndarray) -&gt; np.ndarray\n</code></pre> <p>Preprocess array for display (base: no-op). Returns same shape.</p> Source code in <code>src/pyeyes/cmap/cmap.py</code> <pre><code>def preprocess_data(self, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Preprocess array for display (base: no-op). Returns same shape.\"\"\"\n    return x\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.cmap.ColorMap.get_cmap","title":"get_cmap","text":"<pre><code>get_cmap() -&gt; Union[mcolors.ListedColormap, str]\n</code></pre> <p>Return colormap for display (name or ListedColormap).</p> Source code in <code>src/pyeyes/cmap/cmap.py</code> <pre><code>def get_cmap(self) -&gt; Union[mcolors.ListedColormap, str]:\n    \"\"\"Return colormap for display (name or ListedColormap).\"\"\"\n    return self.cmap\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.QuantitativeColorMap","title":"pyeyes.cmap.QuantitativeColorMap","text":"<pre><code>QuantitativeColorMap(maptype: str, loLev: float, upLev: float)\n</code></pre> <p>               Bases: <code>ColorMap</code></p> <p>Colormap for quantitative maps (T1, T2, etc.) with log-like remap and clipping.</p> <p>Build quantitative colormap from maptype and level range.</p> PARAMETER DESCRIPTION <code>maptype</code> <p>One of QUANTITATIVE_MAPTYPES (e.g. 'T1', 'T2', 'R1').</p> <p> TYPE: <code>str</code> </p> <code>loLev</code> <p>Lower and upper display levels (clip and colormap range).</p> <p> TYPE: <code>float</code> </p> <code>upLev</code> <p>Lower and upper display levels (clip and colormap range).</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pyeyes/cmap/cmap.py</code> <pre><code>def __init__(\n    self,\n    maptype: str,\n    loLev: float,\n    upLev: float,\n):\n    \"\"\"\n    Build quantitative colormap from maptype and level range.\n\n    Parameters\n    ----------\n    maptype : str\n        One of QUANTITATIVE_MAPTYPES (e.g. 'T1', 'T2', 'R1').\n    loLev, upLev : float\n        Lower and upper display levels (clip and colormap range).\n    \"\"\"\n    self.maptype = maptype\n    self.loLev = loLev\n    self.upLev = upLev\n\n    # Generate colormap and epsilon for data processing\n    self.lut_cmap, self.eps = relaxation_color_map(maptype, loLev, upLev)\n\n    # Process colormap into a matplotlib colormap list\n    self.cmap = mcolors.ListedColormap(self.lut_cmap)\n\n    super().__init__(self.cmap)\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.QuantitativeColorMap-functions","title":"Functions","text":""},{"location":"api_core/#pyeyes.cmap.QuantitativeColorMap.preprocess_data","title":"preprocess_data","text":"<pre><code>preprocess_data(x)\n</code></pre> <p>Clip values below loLev and clamp invalid/edge for display.</p> Source code in <code>src/pyeyes/cmap/cmap.py</code> <pre><code>def preprocess_data(self, x):\n    \"\"\"Clip values below loLev and clamp invalid/edge for display.\"\"\"\n    return np.where(\n        x &lt; self.eps,\n        self.loLev - self.eps,\n        np.where(x &lt; self.loLev + self.eps, self.loLev + 1.5 * self.eps, x),\n    )\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.VALID_COLORMAPS","title":"pyeyes.cmap.VALID_COLORMAPS  <code>module-attribute</code>","text":"<pre><code>VALID_COLORMAPS = ['gray', 'jet', 'viridis', 'inferno', 'RdBu', 'Magma', 'hot', 'Quantitative']\n</code></pre>"},{"location":"api_core/#pyeyes.cmap.QUANTITATIVE_MAPTYPES","title":"pyeyes.cmap.QUANTITATIVE_MAPTYPES  <code>module-attribute</code>","text":"<pre><code>QUANTITATIVE_MAPTYPES = ['T1', 'T2', 'R1', 'R2', 'T1rho', 'T1\u03c1', 'R1rho', 'R1\u03c1', 'T2*', 'R2*', 'T2s']\n</code></pre>"},{"location":"api_core/#utilities","title":"Utilities","text":""},{"location":"api_core/#pyeyes.profilers.profile_decorator","title":"pyeyes.profilers.profile_decorator","text":"<pre><code>profile_decorator(enable: bool = True, verbose: bool = True, save: bool = False, save_path: str = './profs/function_profile', max_profs_size: int = 25) -&gt; callable\n</code></pre> <p>Decorator to time function calls and optionally dump cProfile stats.</p> PARAMETER DESCRIPTION <code>enable</code> <p>If False, return identity decorator.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>verbose</code> <p>Print timing (call count, last, avg) to stdout.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>save</code> <p>If True, run cProfile and dump to save_path.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>save_path</code> <p>Prefix for .prof files (e.g. \"./profs/function_profile\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'./profs/function_profile'</code> </p> <code>max_profs_size</code> <p>Max number of .prof files to write before warning.</p> <p> TYPE: <code>int</code> DEFAULT: <code>25</code> </p> RETURNS DESCRIPTION <code>callable</code> <p>Decorator that wraps a function.</p> Source code in <code>src/pyeyes/profilers.py</code> <pre><code>def profile_decorator(\n    enable: bool = True,\n    verbose: bool = True,\n    save: bool = False,\n    save_path: str = \"./profs/function_profile\",\n    max_profs_size: int = 25,\n) -&gt; callable:\n    \"\"\"\n    Decorator to time function calls and optionally dump cProfile stats.\n\n    Parameters\n    ----------\n    enable : bool\n        If False, return identity decorator.\n    verbose : bool\n        Print timing (call count, last, avg) to stdout.\n    save : bool\n        If True, run cProfile and dump to save_path.\n    save_path : str\n        Prefix for .prof files (e.g. \"./profs/function_profile\").\n    max_profs_size : int\n        Max number of .prof files to write before warning.\n\n    Returns\n    -------\n    callable\n        Decorator that wraps a function.\n    \"\"\"\n\n    def decorator(func):\n\n        if not enable:\n            return func\n\n        if hasattr(func, \"__self__\"):\n            ID = f\"{func.__self__.__class__.__name__}.{func.__name__}\"\n        else:\n            ID = f\"{func.__module__}.{func.__name__}\"\n\n        os.makedirs(save_path, exist_ok=True)\n\n        class Profile:\n\n            def __init__(self, name):\n                self.name = name\n                self.call_count = 0\n                self.time_last = 0\n                self.time_avg = 0\n                self.has_warned = False\n\n            @wraps(func)\n            def wrapper(self, *args, **kwargs):\n\n                if save:\n                    pr = cProfile.Profile()\n                    pr.enable()\n\n                start = perf_counter()\n\n                output = func(*args, **kwargs)\n\n                if save:\n                    pr.disable()\n                    if self.call_count &lt; max_profs_size:\n                        pr.dump_stats(f\"{save_path}_call_{self.call_count}.prof\")\n                    elif not self.has_warned:\n                        warnings.warn(\n                            f\"Max profile size reached ({max_profs_size}). Not saving further profiles.\"\n                        )\n                        self.has_warned = True\n\n                end = perf_counter()\n\n                time = end - start\n                time_since_last = end - self.time_last\n\n                self.time_avg = (self.time_avg * self.call_count + time) / (\n                    self.call_count + 1\n                )\n                self.call_count += 1\n\n                if verbose:\n\n                    since_last_str = (\n                        f\"   since last = {time_since_last:0.3f}s)\"\n                        if self.time_last\n                        else \"\"\n                    )\n                    ps = f\"Call {self.call_count}   time: {time:0.3f}s    avg = {self.time_avg:0.3f}s){since_last_str}\"\n                    print(f\"Profiling {self.name}:: {ps}\")\n\n                self.time_last = end\n\n                return output\n\n        return Profile(ID).wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_core/#pyeyes.utils.tonp","title":"pyeyes.utils.tonp","text":"<pre><code>tonp(x: Union[ndarray, list, tuple]) -&gt; np.ndarray\n</code></pre> <p>Convert tensor, list, or tuple to numpy array; pass-through for ndarray.</p> PARAMETER DESCRIPTION <code>x</code> <p>Input to convert.</p> <p> TYPE: <code>np.ndarray, list, or tuple</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Numpy array (complex tensors get resolve_conj on CPU).</p> Source code in <code>src/pyeyes/utils.py</code> <pre><code>def tonp(x: Union[np.ndarray, list, tuple]) -&gt; np.ndarray:\n    \"\"\"\n    Convert tensor, list, or tuple to numpy array; pass-through for ndarray.\n\n    Parameters\n    ----------\n    x : np.ndarray, list, or tuple\n        Input to convert.\n\n    Returns\n    -------\n    np.ndarray\n        Numpy array (complex tensors get resolve_conj on CPU).\n    \"\"\"\n    if TORCH_IMPORTED:\n        if torch.is_tensor(x):\n            # resolve conj if needed\n            if x.is_complex():\n                x = x.detach().cpu().resolve_conj().numpy()\n            else:\n                x = x.detach().cpu().numpy()\n            return x\n        elif isinstance(x, (list, tuple)):\n            return np.array(x)\n        else:\n            return x\n    else:\n        if isinstance(x, (list, tuple)):\n            return np.array(x)\n        else:\n            return x\n</code></pre>"},{"location":"api_core/#pyeyes.utils.normalize","title":"pyeyes.utils.normalize","text":"<pre><code>normalize(shifted, target, ofs=True, mag=False, eps=1e-12)\n</code></pre> <p>Fit shifted = a * target + b (optionally magnitude-only) and return corrected data.</p> PARAMETER DESCRIPTION <code>shifted</code> <p>Data to correct.</p> <p> TYPE: <code>array - like</code> </p> <code>target</code> <p>Reference data.</p> <p> TYPE: <code>array - like</code> </p> <code>ofs</code> <p>Include offset b in fit.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>mag</code> <p>Fit on magnitudes only; phase preserved.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>eps</code> <p>Tolerance for lstsq.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-12</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>a * shifted + b (or magnitude-scaled complex).</p> Source code in <code>src/pyeyes/utils.py</code> <pre><code>def normalize(shifted, target, ofs=True, mag=False, eps=1e-12):\n    \"\"\"\n    Fit shifted = a * target + b (optionally magnitude-only) and return corrected data.\n\n    Parameters\n    ----------\n    shifted : array-like\n        Data to correct.\n    target : array-like\n        Reference data.\n    ofs : bool\n        Include offset b in fit.\n    mag : bool\n        Fit on magnitudes only; phase preserved.\n    eps : float\n        Tolerance for lstsq.\n\n    Returns\n    -------\n    np.ndarray\n        a * shifted + b (or magnitude-scaled complex).\n    \"\"\"\n    shifted = tonp(shifted)\n    target = tonp(target)\n\n    try:\n        # scale\n        scale_func = np.abs if mag else lambda x: x\n        x = scale_func(shifted).flatten()\n        y = scale_func(target).flatten()\n\n        # fit\n        if ofs:\n            A = np.vstack([x, np.ones_like(np.abs(x))]).T\n            a, b = np.linalg.lstsq(A, y, rcond=eps)[0]\n        else:\n            A = np.array([x]).T\n            a = np.linalg.lstsq(A, y, rcond=eps)[0]\n            b = 0\n\n        # numerical tolerance\n        n_decimal = int(np.round(-np.log10(eps)))\n        a, b = np.round(a, n_decimal), np.round(b, n_decimal)\n\n        # apply\n        if mag:\n            out = (a * np.abs(shifted) + b) * np.exp(1j * np.angle(shifted))\n        else:\n            out = a * shifted + b\n\n    except:\n        print(\"Error in normalization. Returning original data.\")\n        out = shifted\n\n    return out\n</code></pre>"},{"location":"api_core/#pyeyes.utils.normalize_scale","title":"pyeyes.utils.normalize_scale","text":"<pre><code>normalize_scale(shifted, target, eps=1e-10, scale_tol=1e-05)\n</code></pre> <p>Normalize shifted to target by a single scale factor (no offset); fallback to lstsq if small.</p> PARAMETER DESCRIPTION <code>shifted</code> <p>Images to align (scale only).</p> <p> TYPE: <code>array - like</code> </p> <code>target</code> <p>Images to align (scale only).</p> <p> TYPE: <code>array - like</code> </p> <code>eps</code> <p>Regularization for scale denominator.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> <code>scale_tol</code> <p>Below this max|shifted|, use normalize() instead.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-05</code> </p> Source code in <code>src/pyeyes/utils.py</code> <pre><code>def normalize_scale(shifted, target, eps=1e-10, scale_tol=1e-5):\n    \"\"\"\n    Normalize shifted to target by a single scale factor (no offset); fallback to lstsq if small.\n\n    Parameters\n    ----------\n    shifted, target : array-like\n        Images to align (scale only).\n    eps : float\n        Regularization for scale denominator.\n    scale_tol : float\n        Below this max|shifted|, use normalize() instead.\n    \"\"\"\n    # If input scale is too small, then fall back to lstsq normalization computation for robustness\n    inp_scale = np.max(np.abs(shifted))\n    if inp_scale &lt; scale_tol:\n        return normalize(shifted, target, ofs=False, mag=np.iscomplexobj(shifted))\n\n    a = np.sum(np.abs(shifted) * np.abs(target)) / (\n        (np.linalg.norm(shifted) ** 2) + eps\n    )\n\n    return shifted * a\n</code></pre>"},{"location":"api_core/#pyeyes.utils.pprint_str","title":"pyeyes.utils.pprint_str","text":"<pre><code>pprint_str(x: float, D: int = 5, E: int = 1) -&gt; str\n</code></pre> <p>Format number: int as-is; very small/large in scientific (E decimals); else float (D digits).</p> PARAMETER DESCRIPTION <code>x</code> <p>Value to format.</p> <p> TYPE: <code>float</code> </p> <code>D</code> <p>Max total digits for float; exponent threshold ~ 10^-(D-1) to 10^(D-1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>E</code> <p>Decimal places in scientific notation.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted string.</p> Source code in <code>src/pyeyes/utils.py</code> <pre><code>def pprint_str(x: float, D: int = 5, E: int = 1) -&gt; str:\n    \"\"\"\n    Format number: int as-is; very small/large in scientific (E decimals); else float (D digits).\n\n    Parameters\n    ----------\n    x : float\n        Value to format.\n    D : int\n        Max total digits for float; exponent threshold ~ 10^-(D-1) to 10^(D-1).\n    E : int\n        Decimal places in scientific notation.\n\n    Returns\n    -------\n    str\n        Formatted string.\n    \"\"\"\n    if isinstance(x, int):\n        return str(x)\n\n    if D == 0:\n        return str(int(round(x)))\n\n    if not (np.isfinite(x)):\n        return \"NaN\"\n\n    # approx integer\n    is_int = False\n    if (x &gt; 1e-8) and np.isclose(round(x) - x, 0):\n        x = int(round(x))\n        is_int = True\n\n    Dact = max(D - 2, 1)\n\n    small_tol = 10 ** (-(Dact))\n    big_tol = 10 ** ((Dact))\n    if abs(x) &lt; small_tol or abs(x) &gt; big_tol:\n        if is_int:\n            return f\"{x:0.0e}\"\n        else:\n            return f\"{x:0.{E}e}\"\n\n    # determine number of digits after decimal point\n    if is_int:\n        return str(x)\n    else:\n        ndec = D - len(str(int(x)))\n        return f\"{x:.{ndec}f}\"\n</code></pre>"},{"location":"api_main/","title":"Main API","text":""},{"location":"api_main/#themes","title":"Themes","text":""},{"location":"api_main/#pyeyes.themes.set_theme","title":"pyeyes.themes.set_theme","text":"<pre><code>set_theme(theme_str: str) -&gt; None\n</code></pre> <p>Set package-wide viewing theme (holoviews/panel).</p> PARAMETER DESCRIPTION <code>theme_str</code> <p>One of \"dark\", \"soft_dark\", \"light\".</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/pyeyes/themes.py</code> <pre><code>def set_theme(theme_str: str) -&gt; None:\n    \"\"\"\n    Set package-wide viewing theme (holoviews/panel).\n\n    Parameters\n    ----------\n    theme_str : str\n        One of \"dark\", \"soft_dark\", \"light\".\n    \"\"\"\n    global VIEW_THEME\n\n    assert (\n        theme_str in SUPPORTED_THEMES\n    ), f\"Unsupported theme: {theme_str}. Must be one of {SUPPORTED_THEMES}.\"\n\n    # set holoviews and panel theme\n    if theme_str in [\"dark\", \"soft_dark\"]:\n        hv.renderer(\"bokeh\").theme = \"dark_minimal\"\n        pn.extension(\n            theme=\"dark\",\n            raw_css=[\n                \"\"\"\n                .bk-tab.bk-active {\n                    color: #FFFFFF !important;  /* White text for active tabs */\n                }\n                .bk-tab {\n                    color: #888888;  /* Grey text for inactive tabs */\n                }\n            \"\"\"\n            ],\n        )\n    else:\n        hv.renderer(\"bokeh\").theme = \"light_minimal\"\n        pn.extension(\n            theme=\"default\",\n            raw_css=[\n                \"\"\"\n                .bk-tab.bk-active {\n                    color: #000000 !important;  /* Black text for active tabs */\n                }\n            \"\"\"\n            ],\n        )\n\n    # Update the global theme\n    VIEW_THEME = SUPPORTED_THEMES[theme_str]\n</code></pre>"},{"location":"api_main/#viewers","title":"Viewers","text":""},{"location":"api_main/#pyeyes.viewers.Viewer","title":"pyeyes.viewers.Viewer","text":"<pre><code>Viewer(data, **kwargs)\n</code></pre> <p>Base class for pyeyes viewers.</p> <p>Provides subscription infrastructure for bidirectional communication between widgets and the viewer/slicer components.</p> <p>Generic class for viewing image data.</p> PARAMETER DESCRIPTION <code>data</code> <p>Image data keyed by name.</p> <p> TYPE: <code>dict of np.ndarray</code> </p> Source code in <code>src/pyeyes/viewers.py</code> <pre><code>def __init__(self, data, **kwargs):\n    \"\"\"\n    Generic class for viewing image data.\n\n    Parameters\n    ----------\n    data : dict of np.ndarray\n        Image data keyed by name.\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"api_main/#pyeyes.viewers.Viewer-functions","title":"Functions","text":""},{"location":"api_main/#pyeyes.viewers.Viewer.launch","title":"launch","text":"<pre><code>launch(title='Viewer', show=True, **kwargs)\n</code></pre> <p>Launch the viewer.</p> PARAMETER DESCRIPTION <code>title</code> <p>Title for the viewer window/tab</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Viewer'</code> </p> <code>show</code> <p>If True, opens browser. If False, starts server silently (useful for testing)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Additional arguments passed to _launch</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>server</code> <p>The Panel server instance (can be used to stop the server)</p> <p> TYPE: <code>Server or None</code> </p> Source code in <code>src/pyeyes/viewers.py</code> <pre><code>def launch(self, title=\"Viewer\", show=True, **kwargs):\n    \"\"\"\n    Launch the viewer.\n\n    Parameters\n    ----------\n    title : str\n        Title for the viewer window/tab\n    show : bool\n        If True, opens browser. If False, starts server silently (useful for testing)\n    **kwargs\n        Additional arguments passed to _launch\n\n    Returns\n    -------\n    server : panel.server.Server or None\n        The Panel server instance (can be used to stop the server)\n    \"\"\"\n    error.install_pyeyes_error_handler()\n    try:\n        return self._launch(title=title, show=show, **kwargs)\n    finally:\n        error.uninstall_pyeyes_error_handler()\n</code></pre>"},{"location":"api_main/#pyeyes.viewers.ComparativeViewer","title":"pyeyes.viewers.ComparativeViewer","text":"<pre><code>ComparativeViewer(data: Union[Dict[str, ndarray], ndarray], named_dims: Optional[Sequence[str]] = None, view_dims: Optional[Sequence[str]] = None, cat_dims: Optional[Dict[str, List]] = {}, config_path: Optional[str] = None)\n</code></pre> <p>               Bases: <code>Viewer</code>, <code>Parameterized</code></p> <p>Viewer for comparing n-dimensional image data with linked slicing and metrics.</p> <p>Builds an interactive MRI/viewer app: multiple images share the same slice indices, viewing dimensions (which 2D plane to show), contrast (clim, colormap), ROI, and optional difference maps / text metrics. Data can be a single array or a dict of arrays (e.g. different reconstructions or image types) with the same shape. Dimension names drive slice widgets and axis labels; categorical dimensions use dropdowns instead of sliders (e.g. \"Map Type\" with options T1, T2, PD).</p> PARAMETER DESCRIPTION <code>data</code> <p>Single image or dict of images. If dict, keys are display names and values are numpy arrays of the same shape. Single array is treated as {\"Image\": array}.</p> <p> TYPE: <code>Union[Dict[str, ndarray], ndarray]</code> </p> <code>named_dims</code> <p>Name for each dimension in order of array axes (length must equal data.ndim). Accepted formats: - List of strings: e.g. [\"x\", \"y\", \"z\"] or [\"Phase\", \"Read\", \"Slice\"]. - String of N characters: e.g. \"xyz\" for 3D (each character is one dim name). - Delimited string: space, comma, semicolon, hyphen, or underscore, e.g.   \"Phase, Read, Slice\" or \"x y z\" (must produce exactly N tokens). If None, defaults to [\"Dim 0\", \"Dim 1\", ...].</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>view_dims</code> <p>Which two dimensions form the initial 2D view (must be in named_dims and non-categorical, non-singleton). If None: uses [\"x\", \"y\"] when those names exist in named_dims, otherwise the first two sliceable dimensions.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>cat_dims</code> <p>Categorical dimensions: key = dimension name (must be in named_dims), value = list of option labels (e.g. {\"Map Type\": [\"T1\", \"T2\", \"PD\"]}). These dimensions use dropdowns instead of integer sliders.</p> <p> TYPE: <code>Optional[Dict[str, List]]</code> DEFAULT: <code>{}</code> </p> <code>config_path</code> <p>Path to a JSON config file saved from the viewer's Export pane. Loads viewer, slicer, and ROI settings (e.g. view dims, clim, colormap, ROI box). A subset of settings can be applied to different datasets or shapes; incompatible image sets or dimension names are handled with warnings and fallbacks.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <p>Simple \u2014 single 3D array, default dim names and xy view:</p> <pre><code>&gt;&gt;&gt; arr = np.random.randn(64, 64, 24)\n&gt;&gt;&gt; viewer = ComparativeViewer(arr)\n&gt;&gt;&gt; viewer.launch()\n</code></pre> <p>Moderate \u2014 dict of 3D images, short dim names, auto xy view:</p> <pre><code>&gt;&gt;&gt; data = {\"Recon\": recon_xyz, \"Reference\": ref_xyz}  # each (H, W, D)\n&gt;&gt;&gt; viewer = ComparativeViewer(data, named_dims=\"xyz\")\n&gt;&gt;&gt; # view_dims not supplied \u2192 defaults to [\"x\", \"y\"]; slice over z\n</code></pre> <p>Complex \u2014 named/view dims as list, categorical dim, and config:</p> <pre><code>&gt;&gt;&gt; # 4D array: (Map Type, Phase, Read, Slice) with 3 map types\n&gt;&gt;&gt; quant = np.stack([t1_vol, t2_vol, pd_vol], axis=0)  # (3, H, W, D)\n&gt;&gt;&gt; viewer = ComparativeViewer(\n...     {\"Quantitative\": quant},\n...     named_dims=[\"Map Type\", \"Phase\", \"Read\", \"Slice\"],\n...     view_dims=[\"Phase\", \"Read\"],\n...     cat_dims={\"Map Type\": [\"T1\", \"T2\", \"PD\"]},\n...     config_path=\"./my_viewer_config.json\",\n... )\n&gt;&gt;&gt; viewer.launch()\n</code></pre> Source code in <code>src/pyeyes/viewers.py</code> <pre><code>def __init__(\n    self,\n    data: Union[Dict[str, np.ndarray], np.ndarray],\n    named_dims: Optional[Sequence[str]] = None,\n    view_dims: Optional[Sequence[str]] = None,\n    cat_dims: Optional[Dict[str, List]] = {},\n    config_path: Optional[str] = None,\n):\n    \"\"\"\n    Viewer for comparing n-dimensional image data with linked slicing and metrics.\n\n    Builds an interactive MRI/viewer app: multiple images share the same slice indices,\n    viewing dimensions (which 2D plane to show), contrast (clim, colormap), ROI, and\n    optional difference maps / text metrics. Data can be a single array or a dict of\n    arrays (e.g. different reconstructions or image types) with the same shape.\n    Dimension names drive slice widgets and axis labels; categorical dimensions use\n    dropdowns instead of sliders (e.g. \"Map Type\" with options T1, T2, PD).\n\n    Parameters\n    ----------\n    data : Union[Dict[str, np.ndarray], np.ndarray]\n        Single image or dict of images. If dict, keys are display names and values\n        are numpy arrays of the same shape. Single array is treated as {\"Image\": array}.\n    named_dims : Optional[Sequence[str]]\n        Name for each dimension in order of array axes (length must equal data.ndim).\n        Accepted formats:\n        - List of strings: e.g. [\"x\", \"y\", \"z\"] or [\"Phase\", \"Read\", \"Slice\"].\n        - String of N characters: e.g. \"xyz\" for 3D (each character is one dim name).\n        - Delimited string: space, comma, semicolon, hyphen, or underscore, e.g.\n          \"Phase, Read, Slice\" or \"x y z\" (must produce exactly N tokens).\n        If None, defaults to [\"Dim 0\", \"Dim 1\", ...].\n    view_dims : Optional[Sequence[str]]\n        Which two dimensions form the initial 2D view (must be in named_dims and\n        non-categorical, non-singleton). If None: uses [\"x\", \"y\"] when those names\n        exist in named_dims, otherwise the first two sliceable dimensions.\n    cat_dims : Optional[Dict[str, List]]\n        Categorical dimensions: key = dimension name (must be in named_dims), value =\n        list of option labels (e.g. {\"Map Type\": [\"T1\", \"T2\", \"PD\"]}). These dimensions\n        use dropdowns instead of integer sliders.\n    config_path : Optional[str]\n        Path to a JSON config file saved from the viewer's Export pane. Loads viewer,\n        slicer, and ROI settings (e.g. view dims, clim, colormap, ROI box). A subset\n        of settings can be applied to different datasets or shapes; incompatible\n        image sets or dimension names are handled with warnings and fallbacks.\n\n    Examples\n    --------\n    **Simple \u2014 single 3D array, default dim names and xy view:**\n\n    &gt;&gt;&gt; arr = np.random.randn(64, 64, 24)\n    &gt;&gt;&gt; viewer = ComparativeViewer(arr)\n    &gt;&gt;&gt; viewer.launch()\n\n    **Moderate \u2014 dict of 3D images, short dim names, auto xy view:**\n\n    &gt;&gt;&gt; data = {\"Recon\": recon_xyz, \"Reference\": ref_xyz}  # each (H, W, D)\n    &gt;&gt;&gt; viewer = ComparativeViewer(data, named_dims=\"xyz\")\n    &gt;&gt;&gt; # view_dims not supplied \u2192 defaults to [\"x\", \"y\"]; slice over z\n\n    **Complex \u2014 named/view dims as list, categorical dim, and config:**\n\n    &gt;&gt;&gt; # 4D array: (Map Type, Phase, Read, Slice) with 3 map types\n    &gt;&gt;&gt; quant = np.stack([t1_vol, t2_vol, pd_vol], axis=0)  # (3, H, W, D)\n    &gt;&gt;&gt; viewer = ComparativeViewer(\n    ...     {\"Quantitative\": quant},\n    ...     named_dims=[\"Map Type\", \"Phase\", \"Read\", \"Slice\"],\n    ...     view_dims=[\"Phase\", \"Read\"],\n    ...     cat_dims={\"Map Type\": [\"T1\", \"T2\", \"PD\"]},\n    ...     config_path=\"./my_viewer_config.json\",\n    ... )\n    &gt;&gt;&gt; viewer.launch()\n    \"\"\"\n\n    from_config = config_path is not None and os.path.exists(config_path)\n\n    # Defaults\n    if not isinstance(data, dict):\n        data = tonp(data)\n\n    if isinstance(data, np.ndarray):\n        data = {\"Image\": data}\n\n    data = {k: tonp(v) for k, v in data.items()}\n\n    first_key = list(data.keys())[0]\n    named_dims = parse_dimensional_input(named_dims, data[first_key].ndim)\n\n    super().__init__(data)\n    param.Parameterized.__init__(self)\n\n    img_names = list(data.keys())\n    img_list = list(data.values())\n\n    N_img = len(img_list)\n    N_dim = len(named_dims)\n\n    self.is_complex_data = any([np.iscomplexobj(img) for img in img_list])\n\n    if cat_dims is not None and len(cat_dims) &gt; 0:\n        assert all(\n            [dim in named_dims for dim in cat_dims.keys()]\n        ), \"Category dimensions must be in dimension_names.\"\n    else:\n        cat_dims = {}\n    self.cat_dims = cat_dims\n\n    # Sliceable dimensions are only those which are non-categorical and not singleton\n    self.noncat_dims = []\n    for i, d in enumerate(named_dims):\n        if d in cat_dims.keys():\n            continue\n        elif data[first_key].shape[i] &lt;= 1:\n            print(f\"Detected '{d}' is singleton. Cannot slice.\")\n            continue\n        else:\n            self.noncat_dims.append(d)\n\n    assert np.array(\n        [img.shape == img_list[0].shape for img in img_list]\n    ).all(), \"All viewed data must have the same input shape.\"\n    assert (\n        N_dim == img_list[0].ndim\n    ), \"Number of dimension names must match the number of dimensions in the data.\"\n\n    if view_dims is not None:\n        view_dims = parse_dimensional_input(view_dims, 2)\n        assert all(\n            [dim in self.noncat_dims for dim in view_dims]\n        ), \"All view dimensions must be non-singleton, non-categorical, and in dimension_names.\"\n    else:\n        # Default viewing dims\n        dl = [dim.lower() for dim in named_dims]\n        if \"x\" in dl and \"y\" in dl:\n            view_dims = [\n                named_dims[dl.index(\"x\")],\n                named_dims[dl.index(\"y\")],\n            ]\n        else:\n            view_dims = self.noncat_dims[:2]\n\n    # Init display images\n    self.param.display_images.objects = img_names\n    self.display_images = img_names\n\n    # Update View dims\n    self.param.vdim_horiz.objects = named_dims\n    self.param.vdim_vert.objects = named_dims\n    self.vdim_horiz = view_dims[0]\n    self.vdim_vert = view_dims[1]\n\n    self.ndims = named_dims\n    self.img_names = img_names\n\n    # Possibly update parameters from config\n    if from_config:\n        # Initi display images and view dims here\n        print(f\"Loading viewer config from {config_path}...\")\n        cfg = self.load_from_config(config_path)\n    else:\n        cfg = None\n\n    self.vdims = (self.vdim_horiz, self.vdim_vert)\n    self.N_img = N_img\n    self.N_dim = N_dim\n\n    # Aggregate data, stacking image type to first axis\n    self.raw_data = data\n\n    # Instantiate dataset for intial view dims\n    self.dataset = self._build_dataset(self.vdims)\n\n    # Initiate scroll handler (creates JS-&gt;Python bridge source)\n    self.scroll_handler = ScrollHandler(\n        callback_func=self._handle_scroll,\n        buffer_time=10,  # [ms]\n    )\n    self.scroll_handle_lock = False\n\n    # Instantiate slicer\n    self.slicer = NDSlicer(\n        self.dataset,\n        self.vdims,\n        cdim=\"ImgName\",\n        clabs=img_names,\n        cat_dims=cat_dims,\n        cfg=cfg,\n        plot_hooks=[\n            self.scroll_handler.build_bokeh_scroll_hook(),  # make the plot the src of scroll event\n        ],\n    )\n\n    # Attach watcher variables to slicer attributes that need GUI updates\n    self.slicer.param.watch(self._roi_state_watcher, \"roi_state\")\n\n    \"\"\"\n    Create Panel Layout\n    \"\"\"\n    # Build panes using Pane-based pattern\n    self.panes = {\n        \"View\": self._init_view_pane(),\n        \"Contrast\": self._init_contrast_pane(),\n        \"ROI\": self._init_roi_pane(),\n        \"Analysis\": self._init_analysis_pane(),\n        \"Misc\": self._init_misc_pane(),\n        \"Export\": self._init_export_pane(),\n    }\n\n    # order of tabs\n    self.tab_order = [\"View\", \"Contrast\", \"ROI\", \"Analysis\", \"Misc\", \"Export\"]\n\n    # Build Control Panel from Panes\n    control_panel = pn.Tabs(\n        *[(tab, self.panes[tab].to_column()) for tab in self.tab_order],\n    )\n\n    # App\n    self.app = pn.Row(control_panel, self.slicer.view)\n\n    # make sure roi_state is consistent with widgets\n    if from_config:\n        self._roi_state_watcher(self.slicer.roi_state)\n        self._update_error_map_type(self.slicer.error_map_type, autoformat=False)\n    else:\n        self._autoscale_clim(event=None)\n</code></pre>"},{"location":"api_main/#pyeyes.viewers.ComparativeViewer-functions","title":"Functions","text":""},{"location":"api_main/#pyeyes.viewers.ComparativeViewer.load_from_config","title":"load_from_config","text":"<pre><code>load_from_config(config_path: str)\n</code></pre> <p>Load viewer/slicer/ROI settings from a JSON config file.</p> PARAMETER DESCRIPTION <code>config_path</code> <p>Path to JSON file (e.g. from Export Config).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Loaded config dict (with metadata for image/dim compatibility).</p> Source code in <code>src/pyeyes/viewers.py</code> <pre><code>def load_from_config(self, config_path: str):\n    \"\"\"\n    Load viewer/slicer/ROI settings from a JSON config file.\n\n    Parameters\n    ----------\n    config_path : str\n        Path to JSON file (e.g. from Export Config).\n\n    Returns\n    -------\n    dict\n        Loaded config dict (with metadata for image/dim compatibility).\n    \"\"\"\n    with open(config_path, \"r\") as f:\n        cfg = json.load(f)\n\n    # add metadata\n    cfg[\"metadata\"] = dict(\n        same_images=True,\n        same_dims=True,\n    )\n\n    # Check that config is compatible with newly supplied data\n    cfg_images = cfg[\"viewer_config\"][\"display_images\"][\"value\"]\n    cfg_ndims = cfg[\"viewer_config\"][\"vdim_horiz\"][\"objects\"]\n\n    # Will not set display image related parameters if not consistent with config\n    if not (set(cfg_images) == set(self.img_names)):\n        warnings.warn(\n            \"Supplied images do not match config - Loading viewer with default image selection.\",\n            RuntimeWarning,\n        )\n        cfg[\"metadata\"][\"same_images\"] = False\n        cfg[\"viewer_config\"].pop(\"display_images\")\n        cfg[\"viewer_config\"].pop(\"single_image_toggle\")\n        cfg[\"slicer_config\"].pop(\"display_images\")\n        cfg[\"slicer_config\"].pop(\"metrics_reference\")\n\n    # Will not set dimension related parameters if not consistent with config\n    if not (set(cfg_ndims) == set(self.ndims)):\n        warnings.warn(\n            \"Config dims do not match supplied named dims. Using default settings.\",\n            RuntimeWarning,\n        )\n        cfg[\"metadata\"][\"same_dims\"] = False\n        cfg[\"viewer_config\"].pop(\"vdim_horiz\")\n        cfg[\"viewer_config\"].pop(\"vdim_vert\")\n        cfg[\"slicer_config\"].pop(\"dim_indices\")\n\n    config.deserialize_parameters(self, cfg[\"viewer_config\"])\n\n    return cfg\n</code></pre>"},{"location":"api_main/#pyeyes.viewers.ComparativeViewer.export_reloadable_pyeyes","title":"export_reloadable_pyeyes","text":"<pre><code>export_reloadable_pyeyes(path: Union[Path, str], num_slices_to_keep: Union[int, Dict[str, int]] | None = None, subsampling: Union[int, Dict[str, int]] = 1, silent: bool = False)\n</code></pre> <p>Save .npz (optionally subsampled) and launcher script to reload viewer.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path for launcher script (.py); .npz and .json written alongside.</p> <p> TYPE: <code>Union[Path, str]</code> </p> <code>num_slices_to_keep</code> <p>Slices per dimension (int or dict by dim). Overrides subsampling.</p> <p> TYPE: <code>Union[int, Dict[str, int]] | None</code> DEFAULT: <code>None</code> </p> <code>subsampling</code> <p>Subsampling step (int or dict by dim). Used if num_slices_to_keep is None.</p> <p> TYPE: <code>Union[int, Dict[str, int]]</code> DEFAULT: <code>1</code> </p> <code>silent</code> <p>If True, launcher uses show=False for testing.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <p>Keep 20 slices in 'z' dimension, 10 in 't' dimension</p> <pre><code>&gt;&gt;&gt; viewer.export_reloadable_pyeyes(\"./viewer.py\", num_slices_to_keep={\"z\": 20, \"t\": 10})\n</code></pre> <p>Use step size of 2 for all subsampleable dimensions</p> <pre><code>&gt;&gt;&gt; viewer.export_reloadable_pyeyes(\"./viewer.py\", subsampling=2)\n</code></pre> Source code in <code>src/pyeyes/viewers.py</code> <pre><code>def export_reloadable_pyeyes(\n    self,\n    path: Union[Path, str],\n    num_slices_to_keep: Union[int, Dict[str, int]] | None = None,\n    subsampling: Union[int, Dict[str, int]] = 1,\n    silent: bool = False,\n):\n    \"\"\"\n    Save .npz (optionally subsampled) and launcher script to reload viewer.\n\n    Parameters\n    ----------\n    path : Union[Path, str]\n        Path for launcher script (.py); .npz and .json written alongside.\n    num_slices_to_keep : Union[int, Dict[str, int]] | None\n        Slices per dimension (int or dict by dim). Overrides subsampling.\n    subsampling : Union[int, Dict[str, int]]\n        Subsampling step (int or dict by dim). Used if num_slices_to_keep is None.\n    silent : bool\n        If True, launcher uses show=False for testing.\n\n    Examples\n    --------\n    Keep 20 slices in 'z' dimension, 10 in 't' dimension\n    &gt;&gt;&gt; viewer.export_reloadable_pyeyes(\"./viewer.py\", num_slices_to_keep={\"z\": 20, \"t\": 10})\n\n    Use step size of 2 for all subsampleable dimensions\n    &gt;&gt;&gt; viewer.export_reloadable_pyeyes(\"./viewer.py\", subsampling=2)\n    \"\"\"\n\n    if isinstance(path, str):\n        path = Path(path)\n\n    out_dir = path.parent\n    os.makedirs(out_dir, exist_ok=True)\n\n    # Determine which dimensions can be subsampled (exclude viewing dims and categorical dims)\n    subsampleable_dims = [\n        dim\n        for dim in self.noncat_dims\n        if dim not in [self.vdim_horiz, self.vdim_vert]\n    ]\n\n    # tmp update to dim_indices\n    dim_indices_old = deepcopy(self.slicer.dim_indices)\n\n    # Calculate step sizes for each dimension\n    step_map = self._calculate_subsampling_steps(\n        subsampleable_dims, num_slices_to_keep, subsampling\n    )\n\n    saved_data = {}\n\n    slicers = []\n    for dim in self.ndims:\n        step = step_map.get(dim, 1)\n        tslc = slice(None, None, step)\n        slicers.append(tslc)\n        if step &gt; 1:\n            inds = np.arange(self.slicer.dim_sizes[dim])[tslc]\n            self.slicer.dim_indices[dim] = inds.shape[0] // 2\n\n    for name, arr in self.raw_data.items():\n        saved_data[name] = arr[tuple(slicers)]\n\n    # Save data and config\n    data_file = path.with_suffix(\".npz\")\n    np.savez_compressed(data_file, **saved_data)\n    self._save_config(path.with_suffix(\".json\"))\n\n    self._create_launcher_script(path, silent=silent)\n\n    # Make launcher executable\n    os.chmod(path, 0o755)\n\n    bokeh_root_logger.info(\n        f\"Export complete: script at {path}, data at {data_file}\"\n    )\n\n    # restore dim_indices\n    with param.parameterized.discard_events(self.slicer):\n        self.slicer.dim_indices = dim_indices_old\n</code></pre>"},{"location":"api_main/#application-launchers","title":"Application Launchers","text":""},{"location":"api_main/#pyeyes.app.launch_viewers","title":"pyeyes.app.launch_viewers","text":"<pre><code>launch_viewers(viewer_dict: Union[Viewer, Dict[str, Viewer]], port: Optional[int] = 0, show=True, **kwargs)\n</code></pre> <p>Serve one or more viewers in a web app.</p> PARAMETER DESCRIPTION <code>viewer_dict</code> <p>Single viewer or dict of name -&gt; viewer (uses .app if present).</p> <p> TYPE: <code>Viewer or Dict[str, Viewer]</code> </p> <code>port</code> <p>Port for server; 0 for auto.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>0</code> </p> <code>show</code> <p>If True, open browser.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Passed to pn.serve.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Server or None</code> <p>Server instance.</p> Source code in <code>src/pyeyes/app.py</code> <pre><code>def launch_viewers(\n    viewer_dict: Union[Viewer, Dict[str, Viewer]],\n    port: Optional[int] = 0,\n    show=True,\n    **kwargs,\n):\n    \"\"\"\n    Serve one or more viewers in a web app.\n\n    Parameters\n    ----------\n    viewer_dict : Viewer or Dict[str, Viewer]\n        Single viewer or dict of name -&gt; viewer (uses .app if present).\n    port : Optional[int]\n        Port for server; 0 for auto.\n    show : bool\n        If True, open browser.\n    **kwargs\n        Passed to pn.serve.\n\n    Returns\n    -------\n    panel.server.Server or None\n        Server instance.\n    \"\"\"\n    if isinstance(viewer_dict, dict):\n        viewer_dict_out = {}\n        for k, v in viewer_dict.items():\n            # check if app is attribute\n            if hasattr(v, \"app\"):\n                viewer_dict_out[k] = v.app\n            else:\n                viewer_dict_out[k] = v\n        viewer_dict = viewer_dict_out\n\n    return pn.serve(\n        viewer_dict,\n        port=port,\n        show=show,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_main/#pyeyes.app.launch_comparative_viewer","title":"pyeyes.app.launch_comparative_viewer","text":"<pre><code>launch_comparative_viewer(data, named_dims=None, view_dims=None, cat_dims=None, config_path=None, title='MRI Viewer', detached=False)\n</code></pre> <p>Launch a ComparativeViewer with one line. See <code>viewer.ComparativeViewer</code> for arguments.</p> Source code in <code>src/pyeyes/app.py</code> <pre><code>def launch_comparative_viewer(\n    data,\n    named_dims=None,\n    view_dims=None,\n    cat_dims=None,\n    config_path=None,\n    title=\"MRI Viewer\",\n    detached=False,\n):\n    \"\"\"\n    Launch a ComparativeViewer with one line.\n    See `viewer.ComparativeViewer` for arguments.\n    \"\"\"\n    if detached:\n        spawn_comparative_viewer_detached(\n            data=data,\n            named_dims=named_dims,\n            view_dims=view_dims,\n            cat_dims=cat_dims,\n            config_path=config_path,\n            title=title,\n        )\n    else:\n        ComparativeViewer(\n            data=data,\n            named_dims=named_dims,\n            view_dims=view_dims,\n            cat_dims=cat_dims,\n            config_path=config_path,\n        ).launch(title=title)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>This document provides a detailed changelog for pyeyes releases, documenting new features, improvements, and bug fixes in each version.</p>"},{"location":"changelog/#v041","title":"v0.4.1","text":"<p>Release Date: February 02 2026</p>"},{"location":"changelog/#overview","title":"Overview","text":"<p>Patch release addressing GUI improvements for pixel inspection and fixing an ROI boundary issue.</p>"},{"location":"changelog/#improvements","title":"Improvements","text":"Area Description Pixel inspection Exposed size and color customization options for pixel popup markers GUI layout More compact Misc tab layout for pixel inspection controls Dependencies Updated package dependencies in <code>pyproject.toml</code>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"Issue Description ROI bounding box Fixed padding issue with ROI bounding box calculations"},{"location":"changelog/#v040","title":"v0.4.0","text":"<p>Release Date: February 01 2026</p>"},{"location":"changelog/#overview_1","title":"Overview","text":"<p>Introduces significant performance improvements, enhanced interactivity, and expanded customization options. This release focuses on making the viewer faster, more responsive, and easier to use with new mouse-based navigation and pixel inspection capabilities.</p>"},{"location":"changelog/#new-features","title":"New Features","text":"Category Feature Description API Input Arg Flexibility <code>ComparativeViewer</code> Dimension inputs now accept multiple formats: (1) no input (default), (2) list of strings (e.g. <code>[\"Read\", \"PE\", \"Slice\"]</code>), or (3) delimited strings (e.g., <code>\"xyz\"</code> or <code>\"x,y,z\"</code> for 3D) Interactivity MouseWheel-based navigation Scroll through slice dimensions directly with mouse wheel. Automatically scrolls along last modified sliceable dimension (including categorical). Bokeh scroll-based zoom now disabled by default. Analysis Image Normalization Options to normalize all images to selected reference dataset for display and error map computation Normalize for Error Metrics Only Normalizes only for error map computation without affecting displayed images (previously \"Normalize Error Maps\") New Misc Tab Font Selection Choose from system fonts for all text elements Display toggles Optional display of image titles and error map titles Grid outline Option to enable grid outline to delineate images Pixel popup inspection Click-to-inspect pixel values across all displayed images. Disabled by default for performance. Features: optional pixel coordinates, toggle for error maps, configurable popup location, clear button Image title editing Edit display names for each image directly in the GUI"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"Issue Description Overlay behavior Fixed overlay behavior issues related to flipping or cropping image dimensions In-figure overlays Resolved inconsistent in-figure overlay locations for different image flip combinations Widget bounds Prevented widgets from incrementing out of bounds (e.g., slice dimensions below 0 or above maximum) Error maps Fixed NaN values in error maps for quantitative map cases and excessive NRMSE values Figure updates Reduced redundant figure update calls for certain widget events Colorbar margins Adjusted colorbar margin overflow Numeric display Improved numeric display consistency with <code>bokeh.models.BasicTickFormatter</code> integration and significant figure control"},{"location":"changelog/#v030","title":"v0.3.0","text":"<p>Release Date: January 2026</p>"},{"location":"changelog/#overview_2","title":"Overview","text":"<p>v0.3.0 focuses on improving error map visualization, expanding quantitative map support, enhancing configuration management, and fixing critical colorbar scaling issues. This release also introduces a prototype 1D viewer and adds support for exporting reloadable viewer instances.</p>"},{"location":"changelog/#new-features_1","title":"New Features","text":"Category Feature Description Error Map Enhancements Error metric overlays Error metrics now overlay on difference maps by default when available. Metrics automatically relocate to error plot area if present, otherwise display on main figure Optional normalization Normalizing error maps is now optional (previously always normalized) Quantitative Map Support T2s support Added support for T2s in quantitative colormaps (uses Navia colormap) Improved colormap selection Improved automatic colormap selection for MRF-like categorical dimensions Configuration &amp; Export Config compatibility Fixed config compatibility issues for error maps Parameter deprecation Resolved parameter deprecation warnings when loading configs Reloadable viewer export Added support for exporting reloadable instances of pyeyes viewer (<code>export_reloadable_pyeyes()</code>) Config serialization Improved config serialization for object selection plot elements Viewer Improvements Title alignment Default image titles now center-aligned rather than left-aligned Display image buttons Display image buttons stack vertically to prevent overflow Hot colormap Added <code>hot</code> colormap option Optional torch import Made torch import optional (graceful fallback if not installed) Detached viewer Added functionality to spawn detached viewer instances Prototype Features 1D viewer Prototyped 1D viewer (<code>launch_1d_viewer</code>) for line plot visualization"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"Issue Description Colorbar scaling Major fixes for vmin/vmax scaling with colorbar limits: fixed vmin out of bounds issues, handled flat/all-zero input cases, resolved GUI/backend inconsistencies Error map formatting Fixed scale rounding issue on autoformatting error maps Tolerance handling Cleaned up tolerances for low image scales Error handling Assigned global error handler only after launching a pyeyes viewer to prevent interference"},{"location":"changelog/#v020","title":"v0.2.0","text":"<p>Release Date: March 2025</p>"},{"location":"changelog/#overview_3","title":"Overview","text":"<p>v0.2.0 expands error map capabilities, improves input flexibility, adds export functionality, and introduces a multi-viewer launcher. This release also includes important fixes for phase error map calculations and singleton dimension handling.</p>"},{"location":"changelog/#new-features_2","title":"New Features","text":"Category Feature Description Error Map Types Relative L1 metric Added Relative L1 difference as a text metric Difference maps Added regular and relative difference maps SSIM maps Added SSIM (Structural Similarity Index) maps Variable naming Improved variable naming for difference metrics Input Flexibility Non-numpy inputs Allow non-numpy inputs to viewer (e.g., PyTorch tensors) with automatic conversion to numpy arrays Single image handling Improved handling of single-image datasets not provided as dictionaries Export Functionality Static HTML export Added option to export interactive GUI to static but sliceable DynamicMap HTML. Export respects current viewing dimensions and supports reduced slice ranges for efficiency. Note: Limited support for categorical dimensions Multi-Viewer Support Multi-viewer launcher Added multi-viewer launcher (<code>launch_viewers()</code>) for launching multiple viewer instances Port handling Improved default port argument handling"},{"location":"changelog/#improvements_1","title":"Improvements","text":"Area Description Title customization Freely editable title font size with improved scaling Singleton dimensions Removed sliders for singleton dimensions (dimensions with size 1) Phase error maps Updated formula for phase error maps to use correct phase difference calculation Plot rendering Fixed plot height bug for font scaling with data pipes"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"Issue Description Metrics calculations Fixed divide-by-zero errors in metrics calculations Config export Fixed export from config bugs Object serialization Limited object serialization to user-changeable parameters only View dimension changes Improved handling of view dimension changes with singleton dimensions"},{"location":"changelog/#v013","title":"v0.1.3","text":"<p>Release Date: January 2025</p>"},{"location":"changelog/#overview_4","title":"Overview","text":"<p>v0.1.3 introduces core features that form the foundation of pyeyes' interactive capabilities: ROI support, configuration save/load, user notifications, improved error handling, and performance optimizations through data streaming.</p>"},{"location":"changelog/#new-features_3","title":"New Features","text":"Category Feature Description ROI Support Interactive region selection Added comprehensive ROI feature for focusing on specific image regions. Draw ROI by selecting two corners to define bounding box. ROI can be displayed as overlay or in separate view. Customizable zoom scale, location, crops, line color, and line width Configuration Management Save-to-config Added save-to-config functionality for repeatability Load-from-config Added load-from-config functionality to restore viewer state. Config files store viewer, slicer, and ROI settings. Enables easy re-examination of similar datasets with consistent settings User Notifications Panel notifications Integrated <code>panel.state.notifications</code> for user-facing messages. Error messages, warnings, and info notifications displayed in the GUI. Better user experience for error handling and status updates Error Handling Function decorators Improved error handling with function decorators. Error handler decorator for graceful error display Global error handler Global error handler for unhandled exceptions Performance Improvements Data streams Improved refresh speed with data streams for slicer updates. Uses HoloViews Pipe streams for efficient data updates. Reduces unnecessary figure regeneration"},{"location":"changelog/#improvements_2","title":"Improvements","text":"Area Description Documentation Included documentation in project build Python requirements Relaxed Python version requirements for broader compatibility Release workflow Added workflow for automatic release to PyPI"},{"location":"changelog/#version-history-summary","title":"Version History Summary","text":"Version Release Date Key Features v0.4.1 February 2026 Additional popup customization, pip dependency fixes v0.4.0 February 2026 Mouse scrolling, pixel popup, normalization options, Misc tab features v0.3.0 January 2026 Error map overlays, reloadable viewer export, colorbar fixes, 1D viewer prototype v0.2.0 March 2025 Additional error maps (SSIM, relative), HTML export, multi-viewer launcher v0.1.3 January 2025 ROI support, config save/load, notifications, error handling, data streams"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We welcome contributions to pyeyes! Whether you're fixing bugs, adding features, or improving documentation, your help is appreciated.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository</li> </ol> <pre><code>git clone https://github.com/zachary-shah/pyeyes.git\ncd pyeyes\n</code></pre> <ol> <li>Create the development environment</li> </ol> <pre><code>mamba env create -n pyeyes --file env.yaml\nmamba activate pyeyes\npip install -e \".[dev,test,docs]\"\npre-commit install\n</code></pre>"},{"location":"contributing/#repository-structure","title":"Repository Structure","text":"<p>Understanding the codebase organization will help you navigate and contribute effectively:</p> <pre><code>src/pyeyes/\n\u251c\u2500\u2500 __init__.py           # Package exports and public API\n\u251c\u2500\u2500 app.py                # Application launchers (launch_viewers, etc.)\n\u251c\u2500\u2500 viewers.py            # ComparativeViewer and base Viewer classes\n\u251c\u2500\u2500 slicers.py            # NDSlicer for managing dimensional slicing\n\u251c\u2500\u2500 roi.py                # ROI functionality and drawing tools\n\u251c\u2500\u2500 metrics.py            # Error metrics (SSIM, NRMSE, etc.)\n\u251c\u2500\u2500 config.py             # Configuration save/load handling\n\u251c\u2500\u2500 themes.py             # Theme definitions and set_theme()\n\u251c\u2500\u2500 utils.py              # Utility functions (normalize, tonp, etc.)\n\u251c\u2500\u2500 error.py              # Error handling decorators\n\u251c\u2500\u2500 enums.py              # Enumerations for viewer settings\n\u251c\u2500\u2500 profilers.py          # Performance profiling decorators\n\u251c\u2500\u2500 gui/                  # GUI widget abstractions\n\u2502   \u251c\u2500\u2500 widget.py         # Base Widget class for panel widgets\n\u2502   \u251c\u2500\u2500 pane.py           # Pane management for tab organization\n\u2502   \u2514\u2500\u2500 scroll.py         # Scroll-based slice navigation\n\u251c\u2500\u2500 cmap/                 # Colormap utilities\n\u2502   \u251c\u2500\u2500 cmap.py           # ColorMap and QuantitativeColorMap classes\n\u2502   \u2514\u2500\u2500 *.csv             # Quantitative colormap data files\n\u2514\u2500\u2500 prototypes/           # Experimental/unsupported features\n    \u251c\u2500\u2500 line.py           # 1D viewer prototype (launch_1d_viewer)\n    \u2514\u2500\u2500 mpl/              # Matplotlib-based diffusion viewer prototype\n</code></pre> <p>Key Design Concepts:</p> <ul> <li><code>gui/widget.py</code>: Provides a generalized <code>Widget</code> interface for creating reusable panel components with consistent behavior</li> <li><code>viewers.py</code>: Contains the main <code>ComparativeViewer</code> class which orchestrates all GUI tabs and data display</li> <li><code>slicers.py</code>: Manages n-dimensional data slicing and caching of view-specific settings</li> <li><code>prototypes/</code>: Contains experimental features not yet part of the stable API; do not rely on these for production use</li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>pyeyes uses <code>pytest</code> for automated testing and <code>playwright</code> for GUI interaction tests.</p> <p>Grab data for pytests:</p> <p>This can be done automatically with <code>tests/download_test_data.py</code>, or manually in bash with:</p> <pre><code>wget https://github.com/zachary-shah/pyeyes/releases/download/test-data-v0.4.0/test-data-v0.4.0.tar.gz\ntar -xzf test-data-v0.4.0.tar.gz -C tests/\n</code></pre> <p>Run the full test suite:</p> <pre><code>pytest\n</code></pre> <p>Run specific test categories:</p> <pre><code># Basic functionality tests\npytest -m basic\n\n# GUI feature tests (requires playwright)\npytest -m gui\n\n# Different configs and data scenarios\npytest -m load\n</code></pre> <p>Interactive demos (not part of automated tests):</p> <pre><code># Files prefixed with 'ztest_' are runnable demos\npython tests/ztest_mrf.py\npython tests/ztest_diffusion.py\n</code></pre> <p>These demo files (<code>ztest_*.py</code>) launch full viewer instances for manual testing and are useful for understanding usage patterns, but they are excluded from the automated test suite.</p> <p>GUI tests with Playwright: GUI tests simulate user interactions (clicks, sliders, tab navigation) using Playwright. To run GUI tests, ensure Playwright browsers are installed:</p> <pre><code>playwright install\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Basic tests (<code>tests/comparative/basic/</code>): Test core functionality like data input modes, dimension handling, and initialization</li> <li>GUI tests (<code>tests/comparative/gui/</code>): Test interactive features using Playwright to simulate user actions</li> <li>Load tests (<code>tests/comparative/load/</code>): Test configuration loading, export functionality, and multi-viewer scenarios</li> <li>Use test data from <code>tests/test-data/</code> for consistency across tests</li> <li>Add new test configurations to <code>tests/cfgs/</code> if needed for your feature</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>For questions or discussion about contributing, please open an issue on GitHub.</p>"},{"location":"user_guide/","title":"User Guide","text":"<p>This guide provides an overview of pyeyes functionality and features. For installation and usage examples, see the README. For  Python API, see API.</p>"},{"location":"user_guide/#what-is-pyeyes","title":"What is pyeyes?","text":"<p><code>pyeyes</code> is an interactive visualization tool for exploring arbitrarily high-dimensional data, designed specifically for MRI analysis but applicable to any multi-dimensional numpy arrays (including complex-valued data).</p>"},{"location":"user_guide/#core-concepts","title":"Core Concepts","text":"<ul> <li>Dataset: An N-dimensional array-like input</li> <li>Named dimensions: Descriptive names for each dimension (e.g., <code>[\"x\", \"y\", \"z\", \"time\", \"contrast\"]</code>)</li> <li>View dimensions (<code>view_dims</code>): The 2D slice currently displayed (typically spatial dimensions like <code>[\"x\", \"y\"]</code>)</li> <li>Slice dimensions (<code>slice_dims</code>): All other dimensions that can be navigated using sliders or selectors</li> </ul> <p>The viewer allows you to interactively navigate through your data by changing which dimensions to view and which slice to display along the remaining dimensions.</p>"},{"location":"user_guide/#comparativeviewer","title":"ComparativeViewer","text":"<p>The <code>ComparativeViewer</code> is the main interface for comparing multiple datasets of the same shape and dimensionality. It enables side-by-side visualization with synchronized navigation, quantitative comparison metrics, and flexible customization options.</p> <p>The interface is organized into a figure window and a control panel, comprised of six panes, each providing specific functionality:</p> <ol> <li>View - Control which dimensions to display and navigate through data</li> <li>Contrast - Adjust color mapping and intensity ranges</li> <li>ROI - Define and zoom into regions of interest</li> <li>Analysis - Compute and display difference maps and comparative metrics</li> <li>Misc - Customize display options, fonts, and enable pixel inspection</li> <li>Export - Save configurations and export static visualizations</li> </ol>"},{"location":"user_guide/#figure-window","title":"Figure Window","text":"<p>The figure window displays the datasets at the current slice. In the top right corner of the figure is the Bokeh Toolbar, containing Bokeh-native navigation tools only for the currently displayed data. The most useful feature is the \"Save\" Icon to save the current displayed data as a <code>.png</code> file.</p>"},{"location":"user_guide/#viewer-control-panel","title":"Viewer Control Panel","text":""},{"location":"user_guide/#view-pane","title":"View Pane","text":"Feature Description View Dimension Selection Choose which 2D slice to display by selecting left/right (L/R) and up/down (U/D) view dimensions Slice Navigation Navigate through non-displayed dimensions using GUI wigets and scrolling over image with mouse wheel Categorical Dimensions Define categorical dimensions (e.g., contrasts) that use dropdown selectors instead of sliders Image Flipping Flip images along L/R or U/D axes Size Scaling Modify base image size with a slider Display Range Control Adjust pixel coordinate ranges to crop the displayed region (for cropping white-space) Single View Mode Toggle between grid view (view all images) and single image view Display Selection Click image names to show/hide specific datasets"},{"location":"user_guide/#contrast-pane","title":"Contrast Pane","text":"Feature Description Complex Data Views Toggle between viewing the real, imaginary, magnitude, and phase components for complex-valued data Color Limits (clim) Adjust intensity range with interactive slider Colormap Selection Choose from various colormaps; supports quantitative maps (T1/T2) for MRF data Auto Scale Automatically set color limits and maps based on data percentiles and view type Colorbar Toggle colorbar display and customize label"},{"location":"user_guide/#roi-pane","title":"ROI Pane","text":"Feature Description Interactive ROI Drawing Click \"Draw ROI\" and select two corners to define a bounding box Zoom Control Set magnification factor for the ROI ROI Position Choose ROI location (top-right, bottom-left, etc.) or display as separate plot Crop Adjustment Fine-tune ROI boundaries with pixel-level crop controls Colormap Use same colormap as main image or select a different one Bounding Box Style Customize line color, width, and interpolation order Overlay Toggle Display ROI as overlay or in separate view below main images"},{"location":"user_guide/#analysis","title":"Analysis","text":"Feature Description Reference Selection Designate one dataset as reference (to be displayed on left-most side of figure) Error Maps Generate difference maps w.r.t. reference (Difference, Rel. Difference, L1, SSIM) Error Map Customization Adjust error scale, colormap, and use autoformat for optimal display Text Metrics Overlay quantitative metrics (PSNR, SSIM, NRMSE, etc.) on images or error maps Metrics Customization Control font size and placement of text metrics Image Normalization Normalize displayed images or only error metrics to reference"},{"location":"user_guide/#misc-pane","title":"Misc Pane","text":"Feature Description Font Selection Choose from system fonts for all text elements Title Display Toggle display of image titles and error map titles Grid Outline Enable grid lines to delineate images Pixel Inspection Click images to show popup with pixel values across all datasets Pixel Popup Options When pixel inspection is enabled, toggle coordinates, error map values, and location; or clear inspection Image Name Editing Customize display names for each dataset directly in the GUI"},{"location":"user_guide/#export-pane","title":"Export Pane","text":"Feature Description Config Export Save current viewer settings to JSON file to re-launch GUI with same or modified data Static HTML Export Export interactive (but non-editable) HTML with sliceable DynamicMaps over the full or sub-sliced dataset"},{"location":"user_guide/#additional-features","title":"Additional Features","text":"Feature Description Config Import Load previously saved configurations as an input to the viewer through <code>config_path</code> Reloadable Python Export Generate standalone <code>.py</code> file to recreate the viewer (currently headless, via <code>viewer.export_reloadable_pyeyes()</code>) Mouse Wheel Scrolling Scroll through slices using mouse wheel along the most recently modified dimension State Caching Contrast and display settings are cached when switching between view types (e.g., magnitude \u2194 phase) Multi-Viewer Support Launch multiple viewer instances simultaneously with <code>launch_viewers()</code> Detached Mode Launch viewer as a detached process with <code>launch_comparative_viewer(..., detached=True)</code> Theme Modification Change between light and dark mode before GUI launch with <code>pyeyes.set_theme()</code>"}]}